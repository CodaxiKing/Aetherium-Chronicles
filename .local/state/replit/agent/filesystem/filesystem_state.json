{"file_contents":{"README.md":{"content":"# Crônicas de Aetherium\n\nUm mod abrangente para Minecraft 1.21.1 que adiciona três sistemas interconectados: criaturas épicas, tecnologia avançada e magia profunda.\n\n## Visão Geral\n\n**Crônicas de Aetherium** é um mod inspirado nos grandes mods clássicos como OreSpawn, Create, Applied Energistics, Botania e Ice and Fire. O mod oferece uma experiência completa de progressão através de três pilares principais:\n\n### 🐉 Sistema de Criaturas e Exploração\n- **20+ mobs únicos** com comportamentos avançados e IA personalizada\n- **3 chefes épicos** com batalhas multi-fase e mecânicas únicas\n- **Estruturas procedimentais massivas** espalhadas por todas as dimensões\n- Sistema de spawn inteligente baseado em biomas\n\n### ⚙️ Sistema de Tecnologia e Automação\n- **Energia cinética visual** com engrenagens, correias e máquinas dinâmicas\n- **Armazenamento digital** com autocrafting avançado estilo Applied Energistics\n- **Processamento de minérios** avançado com proporções de 3:1 e 4:1\n- **Geração de energia** através de moinhos, painéis solares e reatores\n\n### ✨ Sistema de Magia e Misticismo\n- **Magia baseada na natureza** usando plantas e cristais para gerar mana\n- **Criaturas míticas** domesticáveis como dragões e guardiões antigos\n- **Sistema de feitiços** totalmente customizável com componentes combináveis\n- **Artefatos raros** não-craftáveis com habilidades únicas\n\n## Instruções de Configuração do Ambiente no IntelliJ IDEA\n\nEste guia irá orientá-lo na configuração do ambiente de desenvolvimento para o projeto **Crônicas de Aetherium**.\n\n### 1. Pré-requisitos\n\n**Java Development Kit (JDK):** Certifique-se de ter a versão correta do JDK instalada. Para o Minecraft 1.21.1, é necessário o **JDK 21**. Você pode baixá-lo no:\n- [Oracle JDK](https://www.oracle.com/java/technologies/downloads/)\n- [Adoptium (OpenJDK)](https://adoptium.net/)\n\n**IntelliJ IDEA:** Baixe e instale a versão mais recente do IntelliJ IDEA Community ou Ultimate do [site da JetBrains](https://www.jetbrains.com/idea/).\n\n**Git:** Garanta que o Git esteja instalado no seu sistema. Baixe em [git-scm.com](https://git-scm.com/).\n\n### 2. Clonando o Projeto\n\n1. Abra seu terminal ou Git Bash\n2. Navegue até o diretório onde deseja salvar o projeto\n3. Clone o repositório:\n   ```bash\n   git clone [url_do_repositorio]\n   cd cronicas-aetherium\n   ```\n\n### 3. Importando para o IntelliJ\n\n1. **Inicie o IntelliJ IDEA**\n2. Na tela de boas-vindas, selecione **\"Open\"**\n3. Navegue até o arquivo `build.gradle` do projeto e selecione-o\n4. Uma janela irá aparecer. Escolha **\"Open as Project\"**\n5. O IntelliJ começará a importar o projeto e baixar as dependências via Gradle. **Isso pode levar vários minutos** na primeira vez\n\n### 4. Configurando o Workspace\n\n1. **Após a importação inicial**, abra a janela de ferramentas do Gradle no lado direito do IntelliJ:\n   - `View → Tool Windows → Gradle`\n\n2. **Navegue até** `cronicas-aetherium → Tasks → neogradle runs`\n\n3. **As configurações de execução** são geradas automaticamente pelo NeoForge:\n   - `runClient` - Para executar o cliente do Minecraft com o mod\n   - `runServer` - Para executar um servidor de desenvolvimento\n   - `data` - Para gerar dados do mod (receitas, loot tables, etc.)\n\n4. **Após a importação**, clique no botão de recarregar no painel do Gradle para garantir que tudo esteja atualizado\n\n### 5. Executando e Testando o Mod\n\n1. **No canto superior direito** da janela do IntelliJ, você verá um menu para as configurações de execução\n\n2. **Selecione** `runClient` neste menu\n\n3. **Clique no botão verde de \"Play\"** ao lado para iniciar o cliente do Minecraft com seu mod já carregado para testes\n\n### 6. Configurações Adicionais (Opcional)\n\n**Para melhor experiência de desenvolvimento:**\n\n1. **Configure o JDK no projeto:**\n   - `File → Project Structure → Project`\n   - Certifique-se de que está usando JDK 21\n\n2. **Configure a codificação:**\n   - `File → Settings → Editor → File Encodings`\n   - Defina tudo para UTF-8\n\n3. **Configure o Gradle:**\n   - `File → Settings → Build, Execution, Deployment → Build Tools → Gradle`\n   - Use a versão Gradle do wrapper do projeto\n\n### 7. Compilando o Arquivo .jar do Mod\n\n**Para gerar o arquivo .jar distribuível do mod:**\n\n1. **Abra o painel do Gradle**\n2. **Navegue até** `cronicas-aetherium → Tasks → build`\n3. **Execute a tarefa** `build` com um duplo clique\n4. **O arquivo .jar compilado** estará localizado no diretório `build/libs/`\n   - O arquivo sem `-sources` ou `-javadoc` no nome é o que deve ser distribuído\n\n### 8. Estrutura do Projeto\n\n```\ncronicas-aetherium/\n├── src/main/java/com/cronicasaetherium/mod/\n│   ├── CronicasAetherium.java          # Classe principal do mod\n│   ├── registry/                        # Registro de itens, blocos e entidades\n│   ├── items/                          # Classes de itens customizados\n│   ├── blocks/                         # Classes de blocos customizados\n│   ├── entities/                       # Classes de entidades/mobs\n│   └── systems/                        # Sistemas de tecnologia e magia\n├── src/main/resources/\n│   ├── assets/cronicasaetherium/       # Texturas, modelos, sons\n│   ├── data/cronicasaetherium/         # Receitas, loot tables, estruturas\n│   └── META-INF/                       # Configurações do mod\n├── build.gradle                        # Configuração do build\n├── gradle.properties                   # Propriedades do projeto\n└── README.md                           # Este arquivo\n```\n\n## Diretrizes de Desenvolvimento\n\n### Versão e Framework\n- **Minecraft:** 1.21.1\n- **Mod Loader:** NeoForge 21.1.57\n- **Java:** JDK 21\n\n### Comentários no Código\n⚠️ **IMPORTANTE:** Este é um requisito crucial do projeto.\n\n- **Todos os comentários devem ser em português**\n- Explique o propósito de cada pacote, classe e método complexo\n- Esclareça o que linhas ou blocos de código específicos devem fazer\n- **Objetivo:** Outro desenvolvedor deve entender facilmente a estrutura e funcionalidade apenas lendo os comentários\n\n### Integração entre Sistemas\nOs três sistemas principais estão interconectados:\n- **Materiais raros de chefes** → Necessários para máquinas de alto nível\n- **Energia tecnológica** → Pode alimentar rituais mágicos\n- **Essência mágica** → Melhora eficiência de máquinas\n\n### Balanceamento\n- **Progressão equilibrada** através dos três sistemas\n- **Incentivo à exploração** com recompensas únicas por bioma\n- **Desafio crescente** com mecânicas cada vez mais complexas\n\n### Performance\n- **Modelos otimizados** para evitar lag\n- **Texturas eficientes** com resoluções adequadas\n- **Código otimizado** para grandes quantidades de entidades\n\n## Documentação Interna\n\nO mod inclui um **Tomo das Crônicas** craftável que serve como guia completo dentro do jogo, explicando:\n- Como começar com cada sistema\n- Receitas e mecânicas avançadas\n- Localização de estruturas e materiais raros\n- Estratégias para derrotar chefes\n\n## Contribuindo\n\nPara contribuir com o projeto:\n\n1. **Fork** o repositório\n2. **Crie uma branch** para sua feature (`git checkout -b feature/nova-funcionalidade`)\n3. **Siga as diretrizes** de comentários em português\n4. **Teste thoroughamente** suas mudanças\n5. **Submeta um Pull Request** com descrição detalhada\n\n## Licença\n\nEste projeto está licenciado sob a **MIT License** - veja o arquivo LICENSE para detalhes.\n\n## Créditos e Inspirações\n\n- **OreSpawn:** Sistema de criaturas e chefes épicos\n- **Create:** Máquinas visuais e energia cinética\n- **Applied Energistics 2:** Armazenamento digital e automação\n- **Botania:** Magia baseada na natureza\n- **Ice and Fire:** Criaturas míticas e artefatos\n- **Mekanism:** Processamento avançado de recursos\n\n---\n\n*Desenvolvido com ❤️ para a comunidade brasileira de Minecraft*","size_bytes":8045},"replit.md":{"content":"# Crônicas de Aetherium - Status do Projeto\n\n## Visão Geral\nProjeto de mod para Minecraft 1.21.1 usando NeoForge que implementa três sistemas principais: criaturas/exploração, tecnologia/automação, e magia/misticismo.\n\n## Estado Atual do Desenvolvimento\n**Data da última atualização:** 25 de Setembro, 2025\n\n### ✅ Concluído\n- **Ambiente de desenvolvimento:** Java 21, Gradle 8.8, NeoForge 21.1.57\n- **Estrutura base do projeto:** Configuração completa de build.gradle, settings.gradle, gradle.properties\n- **Sistema de registro:** ModItems, ModBlocks, ModEntities, ModCreativeTabs\n- **Configuração do mod:** neoforge.mods.toml com metadados corretos\n- **Localização:** Arquivos de linguagem em português e inglês\n- **Documentação:** README.md completo com instruções detalhadas de setup\n\n### ✅ Setup Replit Concluído\n- **Ambiente Java:** Java 21 instalado e configurado\n- **Build System:** Gradle 8.8 com NeoForge 21.1.57 (configuração correta)\n- **Projeto estruturado:** Todos os arquivos fonte e configurações prontos\n- **Workflow configurado:** Compilação Java operacional para desenvolvimento\n\n### ⚠️ Limitações Replit  \n- **NeoForge decompilation:** Falha devido a limitações de memória/CPU do ambiente\n- **Modo de desenvolvimento:** Replit funciona para edição de código e registros\n- **Builds completos e testes:** Devem ser feitos em ambiente local com mais recursos\n- **Estado atual:** Registros implementados, funcionalidade precisa ser adicionada localmente\n- **Recomendação:** Use Replit para desenvolvimento de registros, ambiente local para BlockEntities/lógica\n\n### 📋 Status da Implementação Tier 1/2\n**TIER 1 - TECNOLOGIA (Registros implementados):**\n- Materiais: Cobre, Estanho, Bronze + Chave de Calibração ✅\n- Sistema de energia: Motor a Vapor (necessita BlockEntity) ✅\n- Logística: Bomba Manual + Canos de Bronze (necessita lógica de fluidos) ✅\n- Máquinas: Triturador, Prensa, Fornalha (necessitam BlockEntities) ✅\n- Automação: Dutos Pneumáticos (necessita lógica de transporte) ✅\n\n**TIER 1 - MAGIA (Registros implementados):**\n- Materiais: Fragmentos de Alma + Essência Espiritual + Faca ✅\n- Estrutura: Pedra Rúnica (necessita lógica de transmutação) ✅\n- Amuletos: Penumbra + Caçador (necessitam funcionalidade) ✅\n- Madeira: Salgueiro Torcido completo ✅\n\n**TIER 2 - TECNOLOGIA (Registros implementados):**  \n- Materiais avançados: Cobalto + Aço Reforçado + Alto-Forno ✅\n- Energia: Geotérmico + Solar (necessitam BlockEntities) ✅\n- Automação: Esteiras + Braço + Fundidora (necessitam lógica) ✅\n- Circuitos: Velocidade, Eficiência, Fortuna ✅\n\n**TIER 2 - MAGIA (Registros implementados):**\n- Materiais: Espíritos + Essência Concentrada ✅  \n- Rituais: Altar Arcano + Pedestais + Infusão (necessitam lógica) ✅\n- Plantas: Rosa Térmica + Cogumelo Lunar + Piscina (necessitam mana) ✅\n- Artefatos: Regeneração + Núcleo + Bolsa (necessitam funcionalidade) ✅\n\n### 📋 Próximas Tarefas (Ambiente Local)\n1. **Implementar BlockEntities:** Adicionar lógica às máquinas (Steam Engine, Crusher, etc.)\n2. **Capabilities:** Sistemas de energia (FE), fluidos, automação  \n3. **GUIs e Menus:** Interfaces para máquinas e rituais\n4. **Recipes/Loot:** Receitas de crafting e loot tables\n5. **Worldgen:** Geração de minérios no mundo\n\n## Arquitetura do Projeto\n\n### Estrutura de Pacotes\n```\ncom.cronicasaetherium.mod/\n├── CronicasAetherium.java          # Classe principal\n├── registry/                       # Sistema de registro\n│   ├── ModItems.java\n│   ├── ModBlocks.java  \n│   ├── ModEntities.java\n│   └── ModCreativeTabs.java\n├── items/                          # Classes de itens (futuro)\n├── blocks/                         # Classes de blocos (futuro)\n├── entities/                       # Classes de entidades (futuro)\n└── systems/                        # Sistemas de tech/magia (futuro)\n```\n\n### Sistemas Planejados\n\n#### 1. Sistema de Criaturas (OreSpawn-inspired)\n- **20+ mobs únicos** com IA avançada\n- **3 chefes épicos** multi-fase\n- **Estruturas procedimentais** massivas\n- **Spawn específico por bioma**\n\n#### 2. Sistema Tecnológico (Create/AE2/Mekanism-inspired)\n- **Energia cinética visual** com engrenagens e correias\n- **Armazenamento digital** com autocrafting\n- **Processamento avançado** de minérios (3:1, 4:1)\n- **Geração de energia** diversificada\n\n#### 3. Sistema Mágico (Botania/Ars Nouveau-inspired)\n- **Magia baseada na natureza** com plantas\n- **Criaturas míticas** domesticáveis\n- **Sistema de feitiços** customizável\n- **Artefatos únicos** não-craftáveis\n\n## Decisões Técnicas\n\n### Build System\n- **NeoForge 21.1.57** para Minecraft 1.21.1\n- **Java 21** (requisito para MC 1.21+)\n- **Gradle 8.8** com wrapper\n- **DeferredRegister** para todos os registros\n\n### Comentários e Documentação\n- **Todos os comentários em português** (requisito do projeto)\n- **Documentação detalhada** para cada classe e método\n- **README abrangente** com setup completo\n\n### Performance e Compatibilidade\n- **Otimização proativa** para grandes quantidades de entidades\n- **Texturas eficientes** com resoluções adequadas\n- **Integração entre sistemas** para progressão equilibrada\n\n## Problemas Conhecidos e Soluções\n\n### Fixes Aplicados\n1. **neoforge.mods.toml:** Correção do loaderVersion para \"[4,)\" \n2. **Entidades temporariamente comentadas** para evitar crashes de build\n3. **BlockItems registrados corretamente** para todos os blocos\n4. **CreativeModeTab** adicionado para organização no jogo\n5. **Mixins desabilitados** temporariamente\n\n### Workflow Status\n- **Minecraft Client workflow** configurado e executando em development mode\n- **Build system** funcionando com dependências NeoForge corretas\n- **Replit environment:** Totalmente configurado para desenvolvimento do mod\n\n## User Preferences\n- **Idioma principal:** Português brasileiro\n- **Estilo de comentários:** Detalhado e explicativo\n- **Documentação:** Completa e acessível para desenvolvedores inexperientes\n- **Progressão:** Sistemas interconectados e equilibrados","size_bytes":6194},"src/main/resources/META-INF/neoforge.mods.toml":{"content":"# Arquivo de configuração do mod para NeoForge\n# Define metadados e dependências do mod Crônicas de Aetherium\n\n# Versão do formato do arquivo de configuração\nmodLoader = \"neoforge\"\nloaderVersion = \"[4,)\"\nlicense = \"MIT\"\n\n# Configurações principais do mod\n[[mods]]\nmodId = \"cronicasaetherium\"\nversion = \"1.0.0\"\ndisplayName = \"Crônicas de Aetherium\"\nupdateJSONURL = \"\"\ndisplayURL = \"\"\nlogoFile = \"\"\ncredits = \"Inspirado por OreSpawn, Create, Applied Energistics, Botania e outros mods clássicos\"\nauthors = \"CronicasAetheriumTeam\"\n\n# Descrição detalhada do mod\ndescription = '''\nUm mod abrangente que adiciona três sistemas interconectados ao Minecraft:\n\n🐉 CRIATURAS E EXPLORAÇÃO\n- Mais de 20 mobs únicos com comportamentos avançados\n- 3 chefes épicos com batalhas de múltiplos estágios\n- Estruturas procedimentais massivas em todas as dimensões\n\n⚙️ TECNOLOGIA E AUTOMAÇÃO\n- Sistema de energia cinética com máquinas visuais\n- Armazenamento digital e autocrafting avançado\n- Processamento de minérios e geração de energia\n\n✨ MAGIA E MISTICISMO\n- Sistema de mana baseado na natureza\n- Criaturas míticas domesticáveis\n- Feitiços customizáveis e artefatos poderosos\n\nTodos os sistemas se integram para criar uma experiência de progressão única e equilibrada.\n'''\n\n# Logo do mod (quando disponível)\n# logoFile = \"logo.png\"\n\n# Configurações de compatibilidade e dependências\n[[dependencies.cronicasaetherium]]\nmodId = \"neoforge\"\ntype = \"required\"\nversionRange = \"[21.1.0,)\"\nordering = \"NONE\"\nside = \"BOTH\"\n\n[[dependencies.cronicasaetherium]]\nmodId = \"minecraft\"\ntype = \"required\"\nversionRange = \"[1.21.1,1.22)\"\nordering = \"NONE\"\nside = \"BOTH\"\n\n# Configurações de compatibilidade (opcional)\n# Aqui podem ser adicionadas dependências opcionais com outros mods\n\n# Configurações de rede (mixins desabilitados por enquanto)\n# [[mixins]]\n# config = \"cronicasaetherium.mixins.json\"\n\n# Configurações adicionais\n[modproperties]\n# Propriedades personalizadas do mod podem ser definidas aqui","size_bytes":2028},"src/main/java/com/cronicasaetherium/mod/CronicasAetherium.java":{"content":"package com.cronicasaetherium.mod;\n\nimport com.mojang.logging.LogUtils;\nimport net.neoforged.api.distmarker.Dist;\nimport net.neoforged.bus.api.IEventBus;\nimport net.neoforged.bus.api.SubscribeEvent;\nimport net.neoforged.fml.ModContainer;\nimport net.neoforged.fml.common.EventBusSubscriber;\nimport net.neoforged.fml.common.Mod;\nimport net.neoforged.fml.config.ModConfig;\nimport net.neoforged.fml.event.lifecycle.FMLClientSetupEvent;\nimport net.neoforged.fml.event.lifecycle.FMLCommonSetupEvent;\nimport net.neoforged.neoforge.common.NeoForge;\nimport net.neoforged.neoforge.event.server.ServerStartingEvent;\nimport net.neoforged.neoforge.event.RegisterCommandsEvent;\nimport org.slf4j.Logger;\nimport com.cronicasaetherium.mod.registry.ModItems;\nimport com.cronicasaetherium.mod.registry.ModBlocks;\nimport com.cronicasaetherium.mod.registry.ModEntities;\nimport com.cronicasaetherium.mod.registry.ModCreativeTabs;\nimport com.cronicasaetherium.mod.registry.ModBlockEntities;\nimport com.cronicasaetherium.mod.common.commands.ProficiencyCommand;\nimport com.cronicasaetherium.mod.config.ModConfig;\n\n/**\n * Classe principal do mod Crônicas de Aetherium\n * \n * Este mod adiciona três sistemas principais ao Minecraft:\n * 1. Sistema de Criaturas e Exploração - Mobs únicos, chefes desafiadores e estruturas\n * 2. Sistema de Tecnologia e Automação - Máquinas, energia e automação\n * 3. Sistema de Magia e Misticismo - Feitiços, mana e artefatos mágicos\n * \n * Desenvolvido para Minecraft 1.21.1 usando NeoForge\n */\n@Mod(CronicasAetherium.MODID)\npublic class CronicasAetherium {\n    \n    // ID único do mod - deve corresponder ao valor em gradle.properties\n    public static final String MODID = \"cronicasaetherium\";\n    \n    // Logger para depuração e informações do mod\n    private static final Logger LOGGER = LogUtils.getLogger();\n    \n    /**\n     * Construtor principal do mod\n     * Inicializa todos os sistemas e registra os event buses necessários\n     * \n     * @param modEventBus Bus de eventos do mod para registro de itens, blocos, etc.\n     * @param modContainer Container do mod para configurações\n     */\n    public CronicasAetherium(IEventBus modEventBus, ModContainer modContainer) {\n        // Registra os event handlers para inicialização comum\n        modEventBus.addListener(this::commonSetup);\n        \n        // Registra todos os sistemas do mod\n        ModItems.register(modEventBus);\n        ModBlocks.register(modEventBus);\n        ModBlockEntities.register(modEventBus);\n        ModEntities.register(modEventBus);\n        ModCreativeTabs.register(modEventBus);\n        \n        // Registra o event bus principal do NeoForge\n        NeoForge.EVENT_BUS.register(this);\n        \n        // Registra o evento de comandos\n        NeoForge.EVENT_BUS.addListener(this::onRegisterCommands);\n        \n        // Registra configurações do mod\n        modContainer.registerConfig(net.neoforged.fml.config.ModConfig.Type.SERVER, ModConfig.SPEC);\n        \n        LOGGER.info(\"Crônicas de Aetherium inicializado com sucesso!\");\n    }\n    \n    /**\n     * Configuração comum executada tanto no cliente quanto no servidor\n     * Aqui são inicializados elementos que funcionam em ambos os lados\n     * \n     * @param event Evento de configuração comum\n     */\n    private void commonSetup(final FMLCommonSetupEvent event) {\n        LOGGER.info(\"Executando configuração comum do Crônicas de Aetherium\");\n        \n        // Configurações que devem ser executadas após o registro de todos os elementos\n        event.enqueueWork(() -> {\n            // TODO: Inicializar sistemas de spawn de mobs\n            // TODO: Registrar receitas dinâmicas\n            // TODO: Configurar sistemas de energia\n            \n            LOGGER.info(\"Configuração comum concluída\");\n        });\n    }\n    \n    /**\n     * Event handler para quando o servidor está iniciando\n     * Usado para configurações específicas do servidor\n     * \n     * @param event Evento de inicialização do servidor\n     */\n    @SubscribeEvent\n    public void onServerStarting(ServerStartingEvent event) {\n        LOGGER.info(\"Crônicas de Aetherium: Servidor iniciando\");\n        \n        // TODO: Configurar geração de estruturas\n        // TODO: Inicializar sistemas de mundo\n    }\n    \n    /**\n     * Event handlers específicos do cliente\n     * Só são executados no lado do cliente (não no servidor dedicado)\n     */\n    @EventBusSubscriber(modid = MODID, bus = EventBusSubscriber.Bus.MOD, value = Dist.CLIENT)\n    public static class ClientModEvents {\n        \n        /**\n         * Configuração específica do cliente\n         * Aqui são registrados renderers, telas, keybindings, etc.\n         * \n         * @param event Evento de configuração do cliente\n         */\n        @SubscribeEvent\n        public static void onClientSetup(FMLClientSetupEvent event) {\n            LOGGER.info(\"Configurando lado cliente do Crônicas de Aetherium\");\n            \n            // TODO: Registrar renderers de entidades\n            // TODO: Registrar telas de GUI\n            // TODO: Configurar keybindings para magia\n            \n            LOGGER.info(\"Configuração do cliente concluída\");\n        }\n    }\n    \n    /**\n     * Evento de registro de comandos\n     * Registra todos os comandos customizados do mod\n     * \n     * @param event Evento de registro de comandos\n     */\n    public void onRegisterCommands(RegisterCommandsEvent event) {\n        ProficiencyCommand.register(event.getDispatcher());\n        LOGGER.info(\"Comandos do Crônicas de Aetherium registrados\");\n    }\n}","size_bytes":5599},"src/main/java/com/cronicasaetherium/mod/config/ModConfig.java":{"content":"package com.cronicasaetherium.mod.config;\n\nimport net.neoforged.neoforge.common.ModConfigSpec;\n\n/**\n * Sistema de configuração do mod Crônicas de Aetherium\n * \n * Esta classe define todas as opções configuráveis do mod, permitindo que\n * administradores de servidor e jogadores personalizem a experiência de\n * acordo com suas preferências.\n * \n * Categorias de configuração:\n * - Proficiência: Multiplicadores de XP e velocidade de progressão\n * - Dimensões: Habilitação e configurações de dimensões customizadas  \n * - Geração: Frequência de minérios, estruturas e spawns\n * - Sinergia: Configurações dos sistemas de integração\n * - Performance: Otimizações e limites de recursos\n * \n * As configurações são aplicadas no lado do servidor e sincronizadas\n * automaticamente com clientes conectados quando necessário.\n */\npublic class ModConfig {\n    \n    public static final ModConfigSpec.Builder BUILDER = new ModConfigSpec.Builder();\n    public static final ModConfigSpec SPEC;\n    \n    // ================================\n    // CONFIGURAÇÕES DE PROFICIÊNCIA\n    // ================================\n    \n    /**\n     * Multiplicador global para ganho de XP de proficiência\n     * \n     * Controla quão rapidamente os jogadores ganham experiência nas\n     * proficiências de engenharia e arcana. Valores maiores aceleram\n     * a progressão, valores menores a tornam mais desafiadora.\n     * \n     * Padrão: 1.0 (velocidade normal)\n     * Faixa: 0.1 - 5.0\n     */\n    public static final ModConfigSpec.DoubleValue PROFICIENCY_XP_MULTIPLIER;\n    \n    /**\n     * XP base concedido por atividades de engenharia\n     * \n     * Define quanto XP de engenharia é ganho por ações como:\n     * - Criar máquinas\n     * - Processar materiais\n     * - Automatizar sistemas\n     * \n     * Padrão: 10\n     * Faixa: 1 - 100\n     */\n    public static final ModConfigSpec.IntValue BASE_ENGINEERING_XP;\n    \n    /**\n     * XP base concedido por atividades arcanas\n     * \n     * Define quanto XP arcana é ganho por ações como:\n     * - Realizar rituais\n     * - Cultivar plantas mágicas\n     * - Criar itens encantados\n     * \n     * Padrão: 15\n     * Faixa: 1 - 100\n     */\n    public static final ModConfigSpec.IntValue BASE_ARCANA_XP;\n    \n    // ================================\n    // CONFIGURAÇÕES DE DIMENSÕES\n    // ================================\n    \n    /**\n     * Habilita ou desabilita a dimensão do Crisol Arcano\n     * \n     * Se desabilitada, o portal não pode ser criado e jogadores\n     * já na dimensão são teleportados de volta ao Overworld.\n     * Útil para servidores que querem focar apenas no conteúdo\n     * do mundo normal.\n     * \n     * Padrão: true (habilitada)\n     */\n    public static final ModConfigSpec.BooleanValue IS_ARCANE_CRUCIBLE_ENABLED;\n    \n    /**\n     * Tempo de cooldown do portal em segundos\n     * \n     * Previne uso excessivo do portal, criando um período\n     * de espera entre viagens. Valor 0 desabilita o cooldown.\n     * \n     * Padrão: 30 segundos\n     * Faixa: 0 - 600 (10 minutos)\n     */\n    public static final ModConfigSpec.IntValue PORTAL_COOLDOWN_SECONDS;\n    \n    // ================================\n    // CONFIGURAÇÕES DE GERAÇÃO\n    // ================================\n    \n    /**\n     * Chance de spawn do Minério de Aetherium por chunk\n     * \n     * Controla a frequência com que minérios de Aetherium são\n     * gerados durante a criação de chunks. Valores maiores\n     * tornam o minério mais comum, valores menores mais raro.\n     * \n     * Padrão: 0.15 (15% de chance por chunk)\n     * Faixa: 0.01 - 1.0\n     */\n    public static final ModConfigSpec.DoubleValue AETHERIUM_ORE_SPAWN_CHANCE;\n    \n    /**\n     * Quantidade máxima de veios de minério por chunk\n     * \n     * Define quantos veios separados de Aetherium podem\n     * aparecer em um único chunk. Veios menores e mais\n     * distribuídos vs. veios maiores e concentrados.\n     * \n     * Padrão: 3\n     * Faixa: 1 - 8\n     */\n    public static final ModConfigSpec.IntValue MAX_AETHERIUM_VEINS_PER_CHUNK;\n    \n    /**\n     * Tamanho médio dos veios de minério\n     * \n     * Controla quantos blocos de minério aparecem em cada veio.\n     * Valores maiores criam depósitos mais abundantes.\n     * \n     * Padrão: 6\n     * Faixa: 2 - 15\n     */\n    public static final ModConfigSpec.IntValue AETHERIUM_VEIN_SIZE;\n    \n    // ================================\n    // CONFIGURAÇÕES DE SINERGIA\n    // ================================\n    \n    /**\n     * Eficiência base das Runas de Eficiência\n     * \n     * Define o bônus percentual base que as runas concedem\n     * às máquinas. Jogadores com maior proficiência arcana\n     * recebem bônus adicionais sobre este valor.\n     * \n     * Padrão: 25% \n     * Faixa: 10 - 100\n     */\n    public static final ModConfigSpec.IntValue RUNE_BASE_EFFICIENCY_BONUS;\n    \n    /**\n     * Multiplicador de conversão de energia para mana\n     * \n     * Controla quanta mana é gerada por unidade de energia\n     * na Infusora de Mana. Valores maiores tornam a conversão\n     * mais eficiente, incentivando sinergia tecnologia→magia.\n     * \n     * Padrão: 1.0\n     * Faixa: 0.5 - 3.0\n     */\n    public static final ModConfigSpec.DoubleValue ENERGY_TO_MANA_MULTIPLIER;\n    \n    // ================================\n    // CONFIGURAÇÕES DE PERFORMANCE\n    // ================================\n    \n    /**\n     * Limite máximo de partículas por área\n     * \n     * Previne lag causado por excesso de efeitos visuais\n     * em áreas densas. Partículas são priorizadas por\n     * importância quando o limite é atingido.\n     * \n     * Padrão: 100\n     * Faixa: 20 - 500\n     */\n    public static final ModConfigSpec.IntValue MAX_PARTICLES_PER_AREA;\n    \n    /**\n     * Intervalo de atualização de máquinas em ticks\n     * \n     * Define com que frequência as máquinas processam\n     * operações. Valores maiores reduzem carga do servidor\n     * mas tornam as máquinas mais lentas.\n     * \n     * Padrão: 20 ticks (1 segundo)\n     * Faixa: 1 - 100\n     */\n    public static final ModConfigSpec.IntValue MACHINE_UPDATE_INTERVAL;\n    \n    // Inicialização estática das configurações\n    static {\n        BUILDER.comment(\"Configurações de Proficiência\")\n               .comment(\"Controla o sistema de habilidades e progressão do jogador\")\n               .push(\"proficiency\");\n        \n        PROFICIENCY_XP_MULTIPLIER = BUILDER\n            .comment(\"Multiplicador global para ganho de XP de proficiência\")\n            .comment(\"Valores maiores aceleram a progressão\")\n            .defineInRange(\"proficiencyXpMultiplier\", 1.0, 0.1, 5.0);\n        \n        BASE_ENGINEERING_XP = BUILDER\n            .comment(\"XP base concedido por atividades de engenharia\")\n            .defineInRange(\"baseEngineeringXp\", 10, 1, 100);\n        \n        BASE_ARCANA_XP = BUILDER\n            .comment(\"XP base concedido por atividades arcanas\")\n            .defineInRange(\"baseArcanaXp\", 15, 1, 100);\n        \n        BUILDER.pop();\n        \n        BUILDER.comment(\"Configurações de Dimensões\")\n               .comment(\"Controla as dimensões customizadas do mod\")\n               .push(\"dimensions\");\n        \n        IS_ARCANE_CRUCIBLE_ENABLED = BUILDER\n            .comment(\"Habilita ou desabilita a dimensão do Crisol Arcano\")\n            .define(\"isArcaneCrucibleEnabled\", true);\n        \n        PORTAL_COOLDOWN_SECONDS = BUILDER\n            .comment(\"Tempo de cooldown do portal em segundos\")\n            .defineInRange(\"portalCooldownSeconds\", 30, 0, 600);\n        \n        BUILDER.pop();\n        \n        BUILDER.comment(\"Configurações de Geração\")\n               .comment(\"Controla spawn de minérios, estruturas e recursos\")\n               .push(\"generation\");\n        \n        AETHERIUM_ORE_SPAWN_CHANCE = BUILDER\n            .comment(\"Chance de spawn do Minério de Aetherium por chunk\")\n            .defineInRange(\"aetheriumOreSpawnChance\", 0.15, 0.01, 1.0);\n        \n        MAX_AETHERIUM_VEINS_PER_CHUNK = BUILDER\n            .comment(\"Quantidade máxima de veios de minério por chunk\")\n            .defineInRange(\"maxAetheriumVeinsPerChunk\", 3, 1, 8);\n        \n        AETHERIUM_VEIN_SIZE = BUILDER\n            .comment(\"Tamanho médio dos veios de minério\")\n            .defineInRange(\"aetheriumVeinSize\", 6, 2, 15);\n        \n        BUILDER.pop();\n        \n        BUILDER.comment(\"Configurações de Sinergia\")\n               .comment(\"Controla a integração entre sistemas tecnológicos e mágicos\")\n               .push(\"synergy\");\n        \n        RUNE_BASE_EFFICIENCY_BONUS = BUILDER\n            .comment(\"Eficiência base das Runas de Eficiência em porcentagem\")\n            .defineInRange(\"runeBaseEfficiencyBonus\", 25, 10, 100);\n        \n        ENERGY_TO_MANA_MULTIPLIER = BUILDER\n            .comment(\"Multiplicador de conversão de energia para mana\")\n            .defineInRange(\"energyToManaMultiplier\", 1.0, 0.5, 3.0);\n        \n        BUILDER.pop();\n        \n        BUILDER.comment(\"Configurações de Performance\")\n               .comment(\"Otimizações e limites para melhor desempenho\")\n               .push(\"performance\");\n        \n        MAX_PARTICLES_PER_AREA = BUILDER\n            .comment(\"Limite máximo de partículas por área\")\n            .defineInRange(\"maxParticlesPerArea\", 100, 20, 500);\n        \n        MACHINE_UPDATE_INTERVAL = BUILDER\n            .comment(\"Intervalo de atualização de máquinas em ticks\")\n            .defineInRange(\"machineUpdateInterval\", 20, 1, 100);\n        \n        BUILDER.pop();\n        \n        SPEC = BUILDER.build();\n    }\n}","size_bytes":9674},"src/main/java/com/cronicasaetherium/mod/registry/ModBlockEntities.java":{"content":"package com.cronicasaetherium.mod.registry;\n\nimport com.cronicasaetherium.mod.CronicasAetherium;\nimport com.cronicasaetherium.mod.blocks.synergy.ManaInfuserBlockEntity;\nimport net.minecraft.core.registries.Registries;\nimport net.minecraft.world.level.block.entity.BlockEntityType;\nimport net.neoforged.bus.api.IEventBus;\nimport net.neoforged.neoforge.registries.DeferredRegister;\n\nimport java.util.function.Supplier;\n\n/**\n * Registro central para todas as BlockEntities do mod Crônicas de Aetherium\n * \n * Esta classe gerencia o registro de todas as BlockEntities customizadas do mod,\n * incluindo máquinas, sistemas mágicos e estruturas especiais.\n * \n * BlockEntities são responsáveis por armazenar dados de blocos que precisam\n * de lógica complexa, inventários, energia ou estados persistentes.\n */\npublic class ModBlockEntities {\n    \n    // DeferredRegister para registro eficiente de BlockEntities\n    public static final DeferredRegister<BlockEntityType<?>> BLOCK_ENTITIES = \n        DeferredRegister.create(Registries.BLOCK_ENTITY_TYPE, CronicasAetherium.MODID);\n    \n    /**\n     * BlockEntity da Infusora de Mana\n     * Responsável pela lógica de conversão de energia em mana\n     * Gerencia inventário, energia e processamento da máquina\n     */\n    public static final Supplier<BlockEntityType<ManaInfuserBlockEntity>> MANA_INFUSER = \n        BLOCK_ENTITIES.register(\"mana_infuser\", () -> \n            BlockEntityType.Builder.of(ManaInfuserBlockEntity::new, ModBlocks.MANA_INFUSER.get())\n                .build(null));\n    \n    /**\n     * Método de registro que deve ser chamado na inicialização do mod\n     * Registra o DeferredRegister no event bus do mod\n     * \n     * @param modEventBus Event bus do mod para registro\n     */\n    public static void register(IEventBus modEventBus) {\n        BLOCK_ENTITIES.register(modEventBus);\n    }\n}","size_bytes":1869},"src/main/java/com/cronicasaetherium/mod/registry/ModBlocks.java":{"content":"package com.cronicasaetherium.mod.registry;\n\nimport com.cronicasaetherium.mod.CronicasAetherium;\nimport net.minecraft.core.registries.Registries;\nimport net.minecraft.world.item.BlockItem;\nimport net.minecraft.world.item.Item;\nimport net.minecraft.world.level.block.Block;\nimport net.minecraft.world.level.block.SoundType;\nimport net.minecraft.world.level.block.state.BlockBehaviour;\nimport net.minecraft.world.level.block.DropExperienceBlock;\nimport net.minecraft.world.level.material.MapColor;\nimport net.minecraft.world.level.block.state.properties.NoteBlockInstrument;\nimport net.minecraft.util.valueproviders.UniformInt;\nimport com.cronicasaetherium.mod.blocks.synergy.ManaInfuserBlock;\nimport com.cronicasaetherium.mod.blocks.synergy.ArcanePortalBlock;\nimport net.neoforged.bus.api.IEventBus;\nimport net.neoforged.neoforge.registries.DeferredRegister;\n\nimport java.util.function.Supplier;\n\n/**\n * Registro central para todos os blocos do mod Crônicas de Aetherium\n * \n * Esta classe gerencia o registro de todos os blocos customizados do mod,\n * incluindo minérios, máquinas, blocos decorativos e estruturais.\n * \n * Organização dos blocos:\n * - Minérios e materiais básicos\n * - Máquinas e componentes tecnológicos\n * - Blocos mágicos e rituais\n * - Blocos decorativos e estruturais\n * - Plantas e vegetação especial\n */\npublic class ModBlocks {\n    \n    // DeferredRegister para registro eficiente de blocos\n    public static final DeferredRegister<Block> BLOCKS = \n        DeferredRegister.create(Registries.BLOCK, CronicasAetherium.MODID);\n    \n    // ================================\n    // MINÉRIOS E MATERIAIS BÁSICOS\n    // ================================\n    \n    // ========= MINÉRIOS TIER 1: TECNOLOGIA ==========\n    \n    /**\n     * Minério de Cobre - Minério básico do sistema tecnológico Tier 1\n     * Encontrado em camadas médias (Y 20-60), base da tecnologia a vapor\n     * Dropa cobre cru que deve ser fundido para uso\n     */\n    public static final Supplier<Block> COPPER_ORE = BLOCKS.register(\"copper_ore\",\n        () -> new DropExperienceBlock(UniformInt.of(0, 2), BlockBehaviour.Properties.of()\n            .strength(3.0f, 3.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.STONE)));\n    \n    /**\n     * Minério de Cobre Deepslate - Versão mais profunda do minério de cobre\n     * Mais raro e difícil de minerar, mas com maior rendimento\n     */\n    public static final Supplier<Block> DEEPSLATE_COPPER_ORE = BLOCKS.register(\"deepslate_copper_ore\",\n        () -> new DropExperienceBlock(UniformInt.of(1, 3), BlockBehaviour.Properties.of()\n            .strength(4.0f, 4.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.DEEPSLATE)));\n    \n    /**\n     * Minério de Estanho - Segundo minério do sistema tecnológico Tier 1\n     * Mais raro que cobre, essencial para criar bronze\n     * Encontrado em veios menores nas profundezas médias (Y 10-40)\n     */\n    public static final Supplier<Block> TIN_ORE = BLOCKS.register(\"tin_ore\",\n        () -> new DropExperienceBlock(UniformInt.of(0, 3), BlockBehaviour.Properties.of()\n            .strength(3.5f, 3.5f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.STONE)));\n    \n    /**\n     * Minério de Estanho Deepslate - Versão mais profunda do minério de estanho\n     */\n    public static final Supplier<Block> DEEPSLATE_TIN_ORE = BLOCKS.register(\"deepslate_tin_ore\",\n        () -> new DropExperienceBlock(UniformInt.of(1, 4), BlockBehaviour.Properties.of()\n            .strength(4.5f, 4.5f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.DEEPSLATE)));\n    \n    /**\n     * Bloco de Bronze - Bloco de armazenamento da primeira liga\n     * Usado como componente estrutural e decorativo\n     * Base para estruturas de máquinas Tier 1\n     */\n    public static final Supplier<Block> BRONZE_BLOCK = BLOCKS.register(\"bronze_block\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(5.0f, 6.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.METAL)));\n    \n    // ========= MINÉRIOS TIER 2: TECNOLOGIA ==========\n    \n    /**\n     * Minério de Cobalto - Minério raro do sistema tecnológico Tier 2\n     * Encontrado apenas em veios raros no subsolo profundo (Y 5-25)\n     * Necessário para criar Aço Reforçado na Fundidora de Ligas\n     */\n    public static final Supplier<Block> COBALT_ORE = BLOCKS.register(\"cobalt_ore\",\n        () -> new DropExperienceBlock(UniformInt.of(3, 6), BlockBehaviour.Properties.of()\n            .strength(4.5f, 5.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.STONE)\n            .lightLevel(state -> 2)));\n    \n    /**\n     * Minério de Cobalto Deepslate - Versão deepslate do cobalto\n     * Ainda mais raro, encontrado nas camadas mais profundas\n     */\n    public static final Supplier<Block> DEEPSLATE_COBALT_ORE = BLOCKS.register(\"deepslate_cobalt_ore\",\n        () -> new DropExperienceBlock(UniformInt.of(4, 7), BlockBehaviour.Properties.of()\n            .strength(5.5f, 6.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.DEEPSLATE)\n            .lightLevel(state -> 3)));\n    \n    /**\n     * Bloco de Aço Reforçado - Bloco de armazenamento da liga avançada Tier 2\n     * Material de construção extremamente resistente\n     * Usado nas estruturas de máquinas avançadas\n     */\n    public static final Supplier<Block> REINFORCED_STEEL_BLOCK = BLOCKS.register(\"reinforced_steel_block\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(8.0f, 12.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.NETHERITE_BLOCK)));\n    \n    // ========= MINÉRIOS MÁGICOS TIER 1 ==========\n    \n    /**\n     * Cristal de Fragmentos de Alma - Fonte natural de fragmentos de alma\n     * Cresce naturalmente em cavernas escuras e biomas sombrios  \n     * Deve ser colhido cuidadosamente para não quebrar\n     */\n    public static final Supplier<Block> SOUL_FRAGMENT_CRYSTAL = BLOCKS.register(\"soul_fragment_crystal\",\n        () -> new DropExperienceBlock(UniformInt.of(2, 5), BlockBehaviour.Properties.of()\n            .strength(1.5f, 2.0f)\n            .sound(SoundType.AMETHYST)\n            .lightLevel(state -> 4)\n            .noOcclusion()));\n    \n    /**\n     * Minério de Aetherium - Minério principal do mod\n     * Encontrado em camadas profundas e estruturas especiais\n     * Dropa cristais de Aetherium quando minerado com picareta encantada\n     */\n    public static final Supplier<Block> AETHERIUM_ORE = BLOCKS.register(\"aetherium_ore\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(5.0f, 6.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.STONE)));\n    \n    /**\n     * Minério de Aetherium Profundo - Versão mais rara encontrada nas profundezas\n     * Dropa mais cristais e tem chance de dropar fragmentos diretamente\n     * Requer ferramentas de diamante ou superiores\n     */\n    public static final Supplier<Block> DEEPSLATE_AETHERIUM_ORE = BLOCKS.register(\"deepslate_aetherium_ore\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(6.0f, 7.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.DEEPSLATE)));\n    \n    /**\n     * Bloco de Aetherium - Bloco de armazenamento e decorativo\n     * Usado em receitas avançadas e como componente estrutural\n     * Emite luz fraca quando ativado por redstone\n     */\n    public static final Supplier<Block> AETHERIUM_BLOCK = BLOCKS.register(\"aetherium_block\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(7.0f, 8.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.METAL)\n            .lightLevel(state -> 3)));\n    \n    // ================================\n    // MÁQUINAS TECNOLÓGICAS BÁSICAS\n    // ================================\n    \n    // ========= MÁQUINAS TIER 1: TECNOLOGIA ==========\n    \n    /**\n     * Motor a Vapor - Coração do sistema tecnológico Tier 1\n     * Queima combustível sólido (carvão, madeira) + água para gerar FE\n     * Primeira fonte de energia do jogador\n     */\n    public static final Supplier<Block> STEAM_ENGINE = BLOCKS.register(\"steam_engine\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(4.0f, 5.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.ANVIL)\n            .lightLevel(state -> 5)));\n    \n    /**\n     * Bomba Manual - Sistema básico de transporte de fluidos\n     * Puxa água de fontes próximas quando clicada\n     * Deve ser conectada a canos de bronze\n     */\n    public static final Supplier<Block> MANUAL_PUMP = BLOCKS.register(\"manual_pump\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(3.0f, 4.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.METAL)));\n    \n    /**\n     * Cano de Bronze - Transporte de fluidos Tier 1\n     * Conecta bombas a máquinas que precisam de água\n     * Componente essencial da logística de fluidos inicial\n     */\n    public static final Supplier<Block> BRONZE_PIPE = BLOCKS.register(\"bronze_pipe\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(2.0f, 3.0f)\n            .sound(SoundType.METAL)\n            .noOcclusion()));\n    \n    /**\n     * Triturador Mecânico - Primeira máquina de processamento\n     * Transforma 1 minério em 2 pós, duplicando rendimento\n     * Funciona com energia do Motor a Vapor\n     */\n    public static final Supplier<Block> MECHANICAL_CRUSHER = BLOCKS.register(\"mechanical_crusher\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(4.0f, 5.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.ANVIL)));\n    \n    /**\n     * Prensa de Engrenagens - Máquina de componentes\n     * Transforma lingotes em engrenagens e placas\n     * Componentes essenciais para outras máquinas\n     */\n    public static final Supplier<Block> GEAR_PRESS = BLOCKS.register(\"gear_press\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(4.0f, 5.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.ANVIL)));\n    \n    /**\n     * Fornalha de Bronze - Fornalha melhorada Tier 1\n     * Queima mais rápido e eficientemente que fornalha de pedra\n     * Usa combustível de forma mais inteligente\n     */\n    public static final Supplier<Block> BRONZE_FURNACE = BLOCKS.register(\"bronze_furnace\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(4.0f, 5.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.STONE)\n            .lightLevel(state -> 7)));\n    \n    /**\n     * Duto Pneumático - Primeira automação Tier 1\n     * Tubos simples e lentos que movem itens\n     * Base da primeira linha de produção automatizada\n     */\n    public static final Supplier<Block> PNEUMATIC_DUCT = BLOCKS.register(\"pneumatic_duct\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(2.0f, 3.0f)\n            .sound(SoundType.METAL)\n            .noOcclusion()));\n    \n    // ========= MÁQUINAS TIER 2: TECNOLOGIA ==========\n    \n    /**\n     * Gerador Geotérmico - Fonte de energia Tier 2\n     * Deve ser colocado perto de lava para gerar FE passivamente\n     * Recompensa exploração de cavernas\n     */\n    public static final Supplier<Block> GEOTHERMAL_GENERATOR = BLOCKS.register(\"geothermal_generator\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(5.0f, 6.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.METAL)\n            .lightLevel(state -> 6)));\n    \n    /**\n     * Painel Solar - Energia limpa e passiva Tier 2\n     * Funciona apenas durante o dia, menos eficaz na chuva\n     * Alternativa sustentável para geração de energia\n     */\n    public static final Supplier<Block> SOLAR_PANEL = BLOCKS.register(\"solar_panel\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(3.0f, 4.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.GLASS)\n            .lightLevel(state -> 2)\n            .noOcclusion()));\n    \n    /**\n     * Esteira Transportadora - Automação avançada Tier 2\n     * Move itens e mobs lentamente de um ponto a outro\n     * Componente básico da logística avançada\n     */\n    public static final Supplier<Block> CONVEYOR_BELT = BLOCKS.register(\"conveyor_belt\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(3.0f, 4.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.METAL)\n            .noCollission()));\n    \n    /**\n     * Braço Mecânico - Automação inteligente Tier 2\n     * Pega itens de inventários e coloca em outros ou em esteiras\n     * Componente chave da automação avançada\n     */\n    public static final Supplier<Block> MECHANICAL_ARM = BLOCKS.register(\"mechanical_arm\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(4.0f, 5.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.METAL)\n            .noOcclusion()));\n    \n    /**\n     * Fundidora de Ligas - Máquina avançada Tier 2\n     * Combina Ferro + Cobalto + FE para criar Aço Reforçado\n     * Porta de entrada para o Tier 2 tecnológico\n     */\n    public static final Supplier<Block> ALLOY_SMELTER = BLOCKS.register(\"alloy_smelter\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(6.0f, 8.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.NETHERITE_BLOCK)\n            .lightLevel(state -> 8)));\n    \n    /**\n     * Alto-Forno Industrial - Estrutura multi-bloco Tier 2\n     * Estrutura 3x3x4 que consome muita energia\n     * Transforma ferro e pó de carvão em Aço Reforçado\n     */\n    public static final Supplier<Block> INDUSTRIAL_BLAST_FURNACE = BLOCKS.register(\"industrial_blast_furnace\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(7.0f, 10.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.NETHERITE_BLOCK)\n            .lightLevel(state -> 10)));\n    \n    /**\n     * Montador Automatizado - Mesa de trabalho programável Tier 2\n     * Fabrica itens em massa seguindo padrões definidos\n     * Essencial para produção em larga escala\n     */\n    public static final Supplier<Block> AUTOMATED_ASSEMBLER = BLOCKS.register(\"automated_assembler\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(5.0f, 6.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.METAL)\n            .lightLevel(state -> 4)));\n    \n    /**\n     * Forja de Aetherium - Máquina básica para processamento de materiais\n     * Primeira máquina que os jogadores podem construir\n     * Funciona com energia cinética ou carvão\n     */\n    public static final Supplier<Block> AETHERIUM_FORGE = BLOCKS.register(\"aetherium_forge\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(4.0f, 5.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.ANVIL)));\n    \n    /**\n     * Moinho de Cristais - Máquina para moer cristais em pó\n     * Produz pó de Aetherium usado em receitas alquímicas\n     * Funciona apenas com energia rotacional\n     */\n    public static final Supplier<Block> CRYSTAL_MILL = BLOCKS.register(\"crystal_mill\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(4.0f, 5.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.STONE)));\n    \n    // ================================\n    // BLOCOS MÁGICOS E RITUAIS\n    // ================================\n    \n    // ========= ESTRUTURAS MÁGICAS TIER 1 ==========\n    \n    /**\n     * Pedra Rúnica - \"Mesa de trabalho\" mágica Tier 1\n     * Bloco único que consome Essência Espiritual\n     * Realiza transmutações simples com itens jogados sobre ela\n     */\n    public static final Supplier<Block> RUNIC_STONE = BLOCKS.register(\"runic_stone\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(3.0f, 4.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.STONE)\n            .lightLevel(state -> 6)));\n    \n    /**\n     * Tronco de Salgueiro Torcido - Madeira mágica do bioma sombrio\n     * Material base para componentes mágicos Tier 1\n     * Cresce apenas nos Bosques Sombrios\n     */\n    public static final Supplier<Block> TWISTED_WILLOW_LOG = BLOCKS.register(\"twisted_willow_log\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(2.0f, 3.0f)\n            .sound(SoundType.WOOD)\n            .lightLevel(state -> 2)));\n    \n    /**\n     * Madeira de Salgueiro Torcido - Versão processada do tronco\n     * Usado em receitas mágicas básicas\n     * Retém propriedades mágicas da árvore original\n     */\n    public static final Supplier<Block> TWISTED_WILLOW_WOOD = BLOCKS.register(\"twisted_willow_wood\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(2.0f, 3.0f)\n            .sound(SoundType.WOOD)\n            .lightLevel(state -> 1)));\n    \n    /**\n     * Folhas de Salgueiro Torcido - Folhas da árvore mágica\n     * Podem ser processadas para extrair essências menores\n     * Crescem naturalmente nas árvores dos Bosques Sombrios\n     */\n    public static final Supplier<Block> TWISTED_WILLOW_LEAVES = BLOCKS.register(\"twisted_willow_leaves\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(0.2f)\n            .sound(SoundType.GRASS)\n            .noOcclusion()\n            .lightLevel(state -> 3)));\n    \n    // ========= ESTRUTURAS MÁGICAS TIER 2 ==========\n    \n    /**\n     * Altar Arcano - Bloco central do sistema de rituais Tier 2\n     * Evolução da Pedra Rúnica para magia avançada\n     * Núcleo das estruturas multi-bloco de rituais\n     */\n    public static final Supplier<Block> ARCANE_ALTAR = BLOCKS.register(\"arcane_altar\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(4.0f, 6.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.STONE)\n            .lightLevel(state -> 10)));\n    \n    /**\n     * Pedestal Rúnico - Componente de rituais Tier 2\n     * Deve ser colocado ao redor do Altar Arcano\n     * Segura ingredientes durante os rituais mágicos\n     */\n    public static final Supplier<Block> RUNIC_PEDESTAL = BLOCKS.register(\"runic_pedestal\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(3.0f, 4.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.STONE)\n            .lightLevel(state -> 4)\n            .noOcclusion()));\n    \n    /**\n     * Altar de Infusão - Estrutura multi-bloco avançada Tier 2\n     * Evolução da Pedra Rúnica com Altar Central + Pedestais\n     * Usado para encantamentos permanentes e criação de artefatos\n     */\n    public static final Supplier<Block> INFUSION_ALTAR = BLOCKS.register(\"infusion_altar\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(5.0f, 7.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.STONE)\n            .lightLevel(state -> 12)));\n    \n    /**\n     * Pedestal de Salgueiro - Componente do Altar de Infusão\n     * Feito com madeira de Salgueiro Torcido\n     * Parte essencial da estrutura multi-bloco\n     */\n    public static final Supplier<Block> WILLOW_PEDESTAL = BLOCKS.register(\"willow_pedestal\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(3.0f, 4.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.WOOD)\n            .lightLevel(state -> 5)\n            .noOcclusion()));\n    \n    // ========= PLANTAS E FLORES MÁGICAS ==========\n    \n    /**\n     * Rosa Térmica - Fonte de mana Tier 2 baseada no calor\n     * Gera mana rapidamente quando exposta ao calor (fogo, lava)\n     * Deve ser cultivada próxima a fontes de calor\n     */\n    public static final Supplier<Block> THERMAL_ROSE = BLOCKS.register(\"thermal_rose\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(0.1f)\n            .sound(SoundType.GRASS)\n            .noCollission()\n            .lightLevel(state -> 6)));\n    \n    /**\n     * Cogumelo Lunar - Fonte de mana Tier 2 noturna\n     * Só cresce no escuro e gera grande quantidade de mana à noite\n     * Alternativa para jogadores que preferem exploração noturna\n     */\n    public static final Supplier<Block> LUNAR_MUSHROOM = BLOCKS.register(\"lunar_mushroom\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(0.1f)\n            .sound(SoundType.FUNGUS)\n            .noCollission()\n            .lightLevel(state -> 8)));\n    \n    /**\n     * Piscina de Mana - Armazenamento de energia mágica\n     * Deve ser construída próxima aos rituais para fornecer mana\n     * Alimentada pelas plantas mágicas e flores\n     */\n    public static final Supplier<Block> MANA_POOL = BLOCKS.register(\"mana_pool\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(3.0f, 4.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.STONE)\n            .lightLevel(state -> 8)\n            .noOcclusion()));\n    \n    // ========= BLOCOS FUNCIONAIS MÁGICOS ==========\n    \n    /**\n     * Selo de Repulsão - Bloco funcional mágico Tier 2\n     * Empurra mobs hostis para longe quando recebe mana\n     * Ferramenta de defesa para bases mágicas\n     */\n    public static final Supplier<Block> REPULSION_SEAL = BLOCKS.register(\"repulsion_seal\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(2.0f, 3.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.STONE)\n            .lightLevel(state -> 5)));\n    \n    /**\n     * Altar Mágico - Bloco central para rituais mágicos\n     * Usado para criar feitiços e encantar itens\n     * Requer estrutura específica ao redor para funcionar\n     */\n    public static final Supplier<Block> MAGIC_ALTAR = BLOCKS.register(\"magic_altar\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(3.0f, 4.0f)\n            .requiresCorrectToolForDrops()\n            .sound(SoundType.STONE)\n            .lightLevel(state -> 7)));\n    \n    /**\n     * Cristal de Mana - Bloco que armazena e transmite energia mágica\n     * Cresce naturalmente em áreas com alta concentração mágica\n     * Pode ser cultivado pelos jogadores usando sementes especiais\n     */\n    public static final Supplier<Block> MANA_CRYSTAL = BLOCKS.register(\"mana_crystal\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(2.0f, 3.0f)\n            .sound(SoundType.AMETHYST)\n            .lightLevel(state -> 10)\n            .noOcclusion()));\n    \n    // ================================\n    // PLANTAS MÁGICAS\n    // ================================\n    \n    /**\n     * Flor de Aetherium - Planta básica que gera mana\n     * Cresce lentamente e deve ser cuidada adequadamente\n     * Base do sistema de magia natural do mod\n     */\n    public static final Supplier<Block> AETHERIUM_FLOWER = BLOCKS.register(\"aetherium_flower\",\n        () -> new Block(BlockBehaviour.Properties.of()\n            .strength(0.1f)\n            .sound(SoundType.GRASS)\n            .noCollission()\n            .lightLevel(state -> 5)));\n    \n    // ================================\n    // BLOCOS DA DIMENSÃO CRISOL ARCANO\n    // ================================\n    \n    /**\n     * Estrutura do Portal Arcano - Bloco que forma a moldura do portal\n     * Este bloco é usado para construir a estrutura que será ativada pelo Coração Instável\n     * Tem propriedades especiais para indicar sua função como portal dimensional\n     */\n    public static final Supplier<Block> ARCANE_PORTAL_FRAME = BLOCKS.register(\"arcane_portal_frame\", \n        () -> new Block(BlockBehaviour.Properties.of()\n            .mapColor(MapColor.COLOR_PURPLE)\n            .instrument(NoteBlockInstrument.BASEDRUM)\n            .requiresCorrectToolForDrops()\n            .strength(50.0F, 1200.0F) // Resistente como obsidiana\n            .sound(SoundType.STONE)\n            .lightLevel(state -> 8) // Brilho sutil\n            .emissiveRendering((state, level, pos) -> true)));\n    \n    /**\n     * Terra Cristalizada - Bloco base da dimensão Crisol Arcano\n     * Substitui a terra comum na nova dimensão, com propriedades cristalinas\n     * Pode ser minerada e usada como material de construção especial\n     */\n    public static final Supplier<Block> CRYSTALLIZED_SOIL = BLOCKS.register(\"crystallized_soil\", \n        () -> new Block(BlockBehaviour.Properties.of()\n            .mapColor(MapColor.COLOR_LIGHT_BLUE)\n            .instrument(NoteBlockInstrument.SNARE)\n            .strength(2.0F, 6.0F) // Mais resistente que terra comum\n            .sound(SoundType.GRAVEL) // Som cristalino\n            .lightLevel(state -> 2))); // Brilho muito suave\n    \n    /**\n     * Minério de Aetherium da Dimensão - Versão exclusiva do Crisol Arcano\n     * Contém mais cristais que a versão do mundo normal\n     * Só pode ser encontrado na dimensão especial\n     */\n    public static final Supplier<Block> DIMENSIONAL_AETHERIUM_ORE = BLOCKS.register(\"dimensional_aetherium_ore\", \n        () -> new DropExperienceBlock(UniformInt.of(3, 7), BlockBehaviour.Properties.of()\n            .mapColor(MapColor.COLOR_CYAN)\n            .instrument(NoteBlockInstrument.BASEDRUM)\n            .requiresCorrectToolForDrops()\n            .strength(4.0F, 3.0F) // Mais fácil de quebrar que obsidiana\n            .sound(SoundType.STONE)\n            .lightLevel(state -> 12))); // Mais brilhante que o normal\n    \n    // ================================\n    // BLOCOS DE SINERGIA (TECNOLOGIA + MAGIA)\n    // ================================\n    \n    /**\n     * Infusora de Mana - Máquina de sinergia Tecnologia → Magia\n     * Converte energia tecnológica em mana utilizável pelo sistema mágico\n     * Interface entre os dois sistemas de progressão\n     */\n    public static final Supplier<Block> MANA_INFUSER = BLOCKS.register(\"mana_infuser\", \n        () -> new ManaInfuserBlock(BlockBehaviour.Properties.of()\n            .mapColor(MapColor.COLOR_PURPLE)\n            .instrument(NoteBlockInstrument.BASEDRUM)\n            .requiresCorrectToolForDrops()\n            .strength(5.0F, 6.0F)\n            .sound(SoundType.METAL)\n            .lightLevel(state -> 6)\n            .emissiveRendering((state, level, pos) -> true)));\n    \n    /**\n     * Portal Arcano Ativo - Bloco de teleportação para o Crisol Arcano\n     * Criado quando a estrutura do portal é ativada com Coração Instável\n     * Permite viagem bidirecional entre dimensões\n     */\n    public static final Supplier<Block> ARCANE_PORTAL = BLOCKS.register(\"arcane_portal\", \n        () -> new ArcanePortalBlock(BlockBehaviour.Properties.of()\n            .mapColor(MapColor.COLOR_PURPLE)\n            .strength(-1.0F, 3600000.0F) // Indestrutível como portal do Nether\n            .sound(SoundType.GLASS)\n            .lightLevel(state -> 15) // Brilho máximo\n            .emissiveRendering((state, level, pos) -> true)\n            .noCollission()));\n    \n    // ================================\n    // REGISTRO DE BLOCKITEMS\n    // ================================\n    \n    /**\n     * BlockItems - Itens correspondentes aos blocos para o inventário\n     * Todos os blocos precisam de um BlockItem para aparecer no inventário\n     */\n    \n    // ========= BLOCKITEMS TIER 1: TECNOLOGIA ==========\n    \n    public static final Supplier<Item> COPPER_ORE_ITEM = ModItems.ITEMS.register(\"copper_ore\",\n        () -> new BlockItem(COPPER_ORE.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> DEEPSLATE_COPPER_ORE_ITEM = ModItems.ITEMS.register(\"deepslate_copper_ore\",\n        () -> new BlockItem(DEEPSLATE_COPPER_ORE.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> TIN_ORE_ITEM = ModItems.ITEMS.register(\"tin_ore\",\n        () -> new BlockItem(TIN_ORE.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> DEEPSLATE_TIN_ORE_ITEM = ModItems.ITEMS.register(\"deepslate_tin_ore\",\n        () -> new BlockItem(DEEPSLATE_TIN_ORE.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> BRONZE_BLOCK_ITEM = ModItems.ITEMS.register(\"bronze_block\",\n        () -> new BlockItem(BRONZE_BLOCK.get(), new Item.Properties()));\n    \n    // ========= BLOCKITEMS TIER 2: TECNOLOGIA ==========\n    \n    public static final Supplier<Item> COBALT_ORE_ITEM = ModItems.ITEMS.register(\"cobalt_ore\",\n        () -> new BlockItem(COBALT_ORE.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> DEEPSLATE_COBALT_ORE_ITEM = ModItems.ITEMS.register(\"deepslate_cobalt_ore\",\n        () -> new BlockItem(DEEPSLATE_COBALT_ORE.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> REINFORCED_STEEL_BLOCK_ITEM = ModItems.ITEMS.register(\"reinforced_steel_block\",\n        () -> new BlockItem(REINFORCED_STEEL_BLOCK.get(), new Item.Properties()));\n    \n    // ========= BLOCKITEMS MÁQUINAS TIER 1 ==========\n    \n    public static final Supplier<Item> STEAM_ENGINE_ITEM = ModItems.ITEMS.register(\"steam_engine\",\n        () -> new BlockItem(STEAM_ENGINE.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> MANUAL_PUMP_ITEM = ModItems.ITEMS.register(\"manual_pump\",\n        () -> new BlockItem(MANUAL_PUMP.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> BRONZE_PIPE_ITEM = ModItems.ITEMS.register(\"bronze_pipe\",\n        () -> new BlockItem(BRONZE_PIPE.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> MECHANICAL_CRUSHER_ITEM = ModItems.ITEMS.register(\"mechanical_crusher\",\n        () -> new BlockItem(MECHANICAL_CRUSHER.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> GEAR_PRESS_ITEM = ModItems.ITEMS.register(\"gear_press\",\n        () -> new BlockItem(GEAR_PRESS.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> BRONZE_FURNACE_ITEM = ModItems.ITEMS.register(\"bronze_furnace\",\n        () -> new BlockItem(BRONZE_FURNACE.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> PNEUMATIC_DUCT_ITEM = ModItems.ITEMS.register(\"pneumatic_duct\",\n        () -> new BlockItem(PNEUMATIC_DUCT.get(), new Item.Properties()));\n    \n    // ========= BLOCKITEMS MÁQUINAS TIER 2 ==========\n    \n    public static final Supplier<Item> GEOTHERMAL_GENERATOR_ITEM = ModItems.ITEMS.register(\"geothermal_generator\",\n        () -> new BlockItem(GEOTHERMAL_GENERATOR.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> SOLAR_PANEL_ITEM = ModItems.ITEMS.register(\"solar_panel\",\n        () -> new BlockItem(SOLAR_PANEL.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> CONVEYOR_BELT_ITEM = ModItems.ITEMS.register(\"conveyor_belt\",\n        () -> new BlockItem(CONVEYOR_BELT.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> MECHANICAL_ARM_ITEM = ModItems.ITEMS.register(\"mechanical_arm\",\n        () -> new BlockItem(MECHANICAL_ARM.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> ALLOY_SMELTER_ITEM = ModItems.ITEMS.register(\"alloy_smelter\",\n        () -> new BlockItem(ALLOY_SMELTER.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> INDUSTRIAL_BLAST_FURNACE_ITEM = ModItems.ITEMS.register(\"industrial_blast_furnace\",\n        () -> new BlockItem(INDUSTRIAL_BLAST_FURNACE.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> AUTOMATED_ASSEMBLER_ITEM = ModItems.ITEMS.register(\"automated_assembler\",\n        () -> new BlockItem(AUTOMATED_ASSEMBLER.get(), new Item.Properties()));\n    \n    // ========= BLOCKITEMS ESTRUTURAS MÁGICAS ==========\n    \n    public static final Supplier<Item> SOUL_FRAGMENT_CRYSTAL_ITEM = ModItems.ITEMS.register(\"soul_fragment_crystal\",\n        () -> new BlockItem(SOUL_FRAGMENT_CRYSTAL.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> RUNIC_STONE_ITEM = ModItems.ITEMS.register(\"runic_stone\",\n        () -> new BlockItem(RUNIC_STONE.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> TWISTED_WILLOW_LOG_ITEM = ModItems.ITEMS.register(\"twisted_willow_log\",\n        () -> new BlockItem(TWISTED_WILLOW_LOG.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> TWISTED_WILLOW_WOOD_ITEM = ModItems.ITEMS.register(\"twisted_willow_wood\",\n        () -> new BlockItem(TWISTED_WILLOW_WOOD.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> TWISTED_WILLOW_LEAVES_ITEM = ModItems.ITEMS.register(\"twisted_willow_leaves\",\n        () -> new BlockItem(TWISTED_WILLOW_LEAVES.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> ARCANE_ALTAR_ITEM = ModItems.ITEMS.register(\"arcane_altar\",\n        () -> new BlockItem(ARCANE_ALTAR.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> RUNIC_PEDESTAL_ITEM = ModItems.ITEMS.register(\"runic_pedestal\",\n        () -> new BlockItem(RUNIC_PEDESTAL.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> INFUSION_ALTAR_ITEM = ModItems.ITEMS.register(\"infusion_altar\",\n        () -> new BlockItem(INFUSION_ALTAR.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> WILLOW_PEDESTAL_ITEM = ModItems.ITEMS.register(\"willow_pedestal\",\n        () -> new BlockItem(WILLOW_PEDESTAL.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> THERMAL_ROSE_ITEM = ModItems.ITEMS.register(\"thermal_rose\",\n        () -> new BlockItem(THERMAL_ROSE.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> LUNAR_MUSHROOM_ITEM = ModItems.ITEMS.register(\"lunar_mushroom\",\n        () -> new BlockItem(LUNAR_MUSHROOM.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> MANA_POOL_ITEM = ModItems.ITEMS.register(\"mana_pool\",\n        () -> new BlockItem(MANA_POOL.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> REPULSION_SEAL_ITEM = ModItems.ITEMS.register(\"repulsion_seal\",\n        () -> new BlockItem(REPULSION_SEAL.get(), new Item.Properties()));\n    \n    // ========= BLOCKITEMS ORIGINAIS ==========\n    public static final Supplier<Item> AETHERIUM_ORE_ITEM = ModItems.ITEMS.register(\"aetherium_ore\",\n        () -> new BlockItem(AETHERIUM_ORE.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> DEEPSLATE_AETHERIUM_ORE_ITEM = ModItems.ITEMS.register(\"deepslate_aetherium_ore\",\n        () -> new BlockItem(DEEPSLATE_AETHERIUM_ORE.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> AETHERIUM_BLOCK_ITEM = ModItems.ITEMS.register(\"aetherium_block\",\n        () -> new BlockItem(AETHERIUM_BLOCK.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> AETHERIUM_FORGE_ITEM = ModItems.ITEMS.register(\"aetherium_forge\",\n        () -> new BlockItem(AETHERIUM_FORGE.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> CRYSTAL_MILL_ITEM = ModItems.ITEMS.register(\"crystal_mill\",\n        () -> new BlockItem(CRYSTAL_MILL.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> MAGIC_ALTAR_ITEM = ModItems.ITEMS.register(\"magic_altar\",\n        () -> new BlockItem(MAGIC_ALTAR.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> MANA_CRYSTAL_ITEM = ModItems.ITEMS.register(\"mana_crystal\",\n        () -> new BlockItem(MANA_CRYSTAL.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> AETHERIUM_FLOWER_ITEM = ModItems.ITEMS.register(\"aetherium_flower\",\n        () -> new BlockItem(AETHERIUM_FLOWER.get(), new Item.Properties()));\n    \n    // BlockItems para blocos da dimensão\n    public static final Supplier<Item> ARCANE_PORTAL_FRAME_ITEM = ModItems.ITEMS.register(\"arcane_portal_frame\",\n        () -> new BlockItem(ARCANE_PORTAL_FRAME.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> CRYSTALLIZED_SOIL_ITEM = ModItems.ITEMS.register(\"crystallized_soil\",\n        () -> new BlockItem(CRYSTALLIZED_SOIL.get(), new Item.Properties()));\n    \n    public static final Supplier<Item> DIMENSIONAL_AETHERIUM_ORE_ITEM = ModItems.ITEMS.register(\"dimensional_aetherium_ore\",\n        () -> new BlockItem(DIMENSIONAL_AETHERIUM_ORE.get(), new Item.Properties()));\n    \n    // BlockItems para blocos de sinergia\n    public static final Supplier<Item> MANA_INFUSER_ITEM = ModItems.ITEMS.register(\"mana_infuser\",\n        () -> new BlockItem(MANA_INFUSER.get(), new Item.Properties()));\n    \n    // Portal arcano não precisa de BlockItem (criado dinamicamente)\n    \n    /**\n     * Método de registro que deve ser chamado na inicialização do mod\n     * Registra o DeferredRegister no event bus do mod\n     * \n     * @param modEventBus Event bus do mod para registro\n     */\n    public static void register(IEventBus modEventBus) {\n        BLOCKS.register(modEventBus);\n    }\n}","size_bytes":37146},"src/main/java/com/cronicasaetherium/mod/registry/ModCreativeTabs.java":{"content":"package com.cronicasaetherium.mod.registry;\n\nimport com.cronicasaetherium.mod.CronicasAetherium;\nimport net.minecraft.core.registries.Registries;\nimport net.minecraft.network.chat.Component;\nimport net.minecraft.world.item.CreativeModeTab;\nimport net.minecraft.world.item.ItemStack;\nimport net.neoforged.bus.api.IEventBus;\nimport net.neoforged.neoforge.registries.DeferredRegister;\n\nimport java.util.function.Supplier;\n\n/**\n * Registro central para as abas do modo criativo do mod Crônicas de Aetherium\n * \n * Esta classe define as abas personalizadas que aparecem no modo criativo,\n * organizando os itens do mod de forma lógica para facilitar o acesso.\n * \n * Organização das abas:\n * - Aba Principal: Itens básicos e materiais fundamentais\n * - Aba Tecnologia: Máquinas, componentes e sistemas tecnológicos\n * - Aba Magia: Itens mágicos, essências e artefatos\n * - Aba Blocos: Todos os blocos decorativos e funcionais\n */\npublic class ModCreativeTabs {\n    \n    // DeferredRegister para registro eficiente das abas criativas\n    public static final DeferredRegister<CreativeModeTab> CREATIVE_MODE_TABS = \n        DeferredRegister.create(Registries.CREATIVE_MODE_TAB, CronicasAetherium.MODID);\n    \n    /**\n     * Aba Principal do Mod - Crônicas de Aetherium\n     * Contém os itens mais importantes e básicos do mod\n     * \n     * Inclui:\n     * - Materiais básicos Tier 1 e 2\n     * - Guias e livros do mod\n     * - Itens de invocação de chefes\n     * - Materiais básicos essenciais\n     */\n    public static final Supplier<CreativeModeTab> CRONICAS_AETHERIUM_TAB = CREATIVE_MODE_TABS.register(\"main\",\n        () -> CreativeModeTab.builder()\n            .title(Component.translatable(\"itemGroup.cronicasaetherium.main\"))\n            .icon(() -> new ItemStack(ModItems.AETHERIUM_CRYSTAL.get()))\n            .displayItems((parameters, output) -> {\n                // TIER 1: Materiais Tecnológicos - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModItems.RAW_COPPER.get());\n                // output.accept(ModItems.COPPER_INGOT.get());\n                // output.accept(ModItems.RAW_TIN.get());\n                // output.accept(ModItems.TIN_INGOT.get());\n                // output.accept(ModItems.BRONZE_INGOT.get());\n                // output.accept(ModItems.COPPER_DUST.get());\n                // output.accept(ModItems.TIN_DUST.get());\n                \n                // TIER 1: Materiais Mágicos - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModItems.SOUL_FRAGMENT.get());\n                // output.accept(ModItems.SPIRIT_ESSENCE.get());\n                \n                // TIER 2: Materiais Avançados - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModItems.RAW_COBALT.get());\n                // output.accept(ModItems.COBALT_INGOT.get());\n                // output.accept(ModItems.REINFORCED_STEEL_INGOT.get());\n                // output.accept(ModItems.ADAMANTINE_HEART.get());\n                \n                // TIER 2: Materiais Mágicos Avançados - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModItems.MALIGNANT_SPIRIT.get());\n                // output.accept(ModItems.PURE_SPIRIT.get());\n                // output.accept(ModItems.ARCANE_SPIRIT.get());\n                // output.accept(ModItems.CONCENTRATED_MAGIC_ESSENCE.get());\n                \n                // Materiais Aetherium Originais\n                output.accept(ModItems.AETHERIUM_CRYSTAL.get());\n                output.accept(ModItems.AETHERIUM_FRAGMENT.get());\n                output.accept(ModItems.MAGIC_ESSENCE.get());\n                \n                // Guias e Livros\n                output.accept(ModItems.CHRONICLES_TOME.get());\n                // output.accept(ModItems.HIDDEN_CODEX.get()); // TEMPORARIAMENTE COMENTADO\n                output.accept(ModItems.WORN_JOURNAL.get());\n                \n                // Itens de invocação de chefes\n                output.accept(ModItems.ANCIENT_DRAGON_AMULET.get());\n                output.accept(ModItems.CORRUPTED_CORE.get());\n                output.accept(ModItems.VOID_ORB.get());\n                \n                // Dimensão\n                output.accept(ModItems.UNSTABLE_HEART.get());\n                output.accept(ModBlocks.ARCANE_PORTAL_FRAME_ITEM.get());\n            })\n            .build());\n    \n    /**\n     * Aba de Tecnologia - Sistema Tecnológico\n     * Contém máquinas, componentes e itens relacionados à automação\n     * \n     * Inclui:\n     * - TIER 1: Tecnologia a vapor e máquinas básicas\n     * - TIER 2: Geração avançada de energia e automação\n     * - Componentes e circuitos de aprimoramento\n     */\n    public static final Supplier<CreativeModeTab> TECHNOLOGY_TAB = CREATIVE_MODE_TABS.register(\"technology\",\n        () -> CreativeModeTab.builder()\n            .title(Component.translatable(\"itemGroup.cronicasaetherium.technology\"))\n            .icon(() -> new ItemStack(ModItems.AETHERIUM_GEAR.get()))\n            .displayItems((parameters, output) -> {\n                // TIER 1: Ferramentas - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModItems.CALIBRATION_WRENCH.get());\n                \n                // TIER 1: Componentes Básicos - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModItems.BRONZE_GEAR.get());\n                // output.accept(ModItems.BRONZE_PLATE.get());\n                \n                // TIER 1: Energia e Fluidos - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModBlocks.STEAM_ENGINE_ITEM.get());\n                // output.accept(ModBlocks.MANUAL_PUMP_ITEM.get());\n                // output.accept(ModBlocks.BRONZE_PIPE_ITEM.get());\n                \n                // TIER 1: Máquinas Básicas - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModBlocks.MECHANICAL_CRUSHER_ITEM.get());\n                // output.accept(ModBlocks.GEAR_PRESS_ITEM.get());\n                // output.accept(ModBlocks.BRONZE_FURNACE_ITEM.get());\n                \n                // TIER 1: Automação Inicial - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModBlocks.PNEUMATIC_DUCT_ITEM.get());\n                \n                // TIER 2: Fontes de Energia Avançadas - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModBlocks.GEOTHERMAL_GENERATOR_ITEM.get());\n                // output.accept(ModBlocks.SOLAR_PANEL_ITEM.get());\n                \n                // TIER 2: Automação Avançada - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModBlocks.CONVEYOR_BELT_ITEM.get());\n                // output.accept(ModBlocks.MECHANICAL_ARM_ITEM.get());\n                \n                // TIER 2: Máquinas Avançadas - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModBlocks.ALLOY_SMELTER_ITEM.get());\n                // output.accept(ModBlocks.INDUSTRIAL_BLAST_FURNACE_ITEM.get());\n                // output.accept(ModBlocks.AUTOMATED_ASSEMBLER_ITEM.get());\n                \n                // TIER 2: Componentes Avançados - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModItems.REINFORCED_STEEL_GEAR.get());\n                // output.accept(ModItems.SPEED_UPGRADE_CIRCUIT.get());\n                // output.accept(ModItems.EFFICIENCY_UPGRADE_CIRCUIT.get());\n                // output.accept(ModItems.FORTUNE_UPGRADE_CIRCUIT.get());\n                \n                // Componentes Originais\n                output.accept(ModItems.AETHERIUM_GEAR.get());\n                output.accept(ModItems.MAGIC_CIRCUIT.get());\n                output.accept(ModBlocks.AETHERIUM_FORGE_ITEM.get());\n                output.accept(ModBlocks.CRYSTAL_MILL_ITEM.get());\n                \n                // Sinergia\n                output.accept(ModBlocks.MANA_INFUSER_ITEM.get());\n            })\n            .build());\n    \n    /**\n     * Aba de Magia - Sistema Mágico\n     * Contém itens mágicos, essências e componentes do sistema de magia\n     * \n     * Inclui:\n     * - TIER 1: Magia básica e primeiros amuletos\n     * - TIER 2: Sistema de rituais e magia avançada\n     * - Plantas mágicas e fontes de mana\n     */\n    public static final Supplier<CreativeModeTab> MAGIC_TAB = CREATIVE_MODE_TABS.register(\"magic\",\n        () -> CreativeModeTab.builder()\n            .title(Component.translatable(\"itemGroup.cronicasaetherium.magic\"))\n            .icon(() -> new ItemStack(ModItems.MAGIC_ESSENCE.get()))\n            .displayItems((parameters, output) -> {\n                // TIER 1: Ferramentas Mágicas - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModItems.SACRIFICE_KNIFE.get());\n                // output.accept(ModItems.FOREST_WAND.get());\n                \n                // TIER 1: Amuletos e Anéis - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModItems.PENUMBRA_AMULET.get());\n                // output.accept(ModItems.HUNTER_RING.get());\n                \n                // TIER 1: Estruturas Básicas - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModBlocks.RUNIC_STONE_ITEM.get());\n                \n                // TIER 2: Amuletos Avançados - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModItems.REGENERATION_RING.get());\n                // output.accept(ModItems.ANIMIC_CORE.get());\n                // output.accept(ModItems.SPIRIT_POUCH.get());\n                \n                // TIER 2: Estruturas de Rituais - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModBlocks.ARCANE_ALTAR_ITEM.get());\n                // output.accept(ModBlocks.RUNIC_PEDESTAL_ITEM.get());\n                // output.accept(ModBlocks.INFUSION_ALTAR_ITEM.get());\n                // output.accept(ModBlocks.WILLOW_PEDESTAL_ITEM.get());\n                \n                // Plantas e Flores Mágicas - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModBlocks.THERMAL_ROSE_ITEM.get());\n                // output.accept(ModBlocks.LUNAR_MUSHROOM_ITEM.get());\n                // output.accept(ModBlocks.MANA_POOL_ITEM.get());\n                \n                // Blocos Funcionais - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModBlocks.REPULSION_SEAL_ITEM.get());\n                \n                // Madeira Mágica - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModBlocks.TWISTED_WILLOW_LOG_ITEM.get());\n                // output.accept(ModBlocks.TWISTED_WILLOW_WOOD_ITEM.get());\n                // output.accept(ModBlocks.TWISTED_WILLOW_LEAVES_ITEM.get());\n                \n                // Materiais Mágicos Originais\n                output.accept(ModItems.MAGIC_ESSENCE.get());\n                output.accept(ModItems.RUNE_OF_EFFICIENCY.get());\n                output.accept(ModBlocks.MAGIC_ALTAR_ITEM.get());\n                output.accept(ModBlocks.MANA_CRYSTAL_ITEM.get());\n                output.accept(ModBlocks.AETHERIUM_FLOWER_ITEM.get());\n            })\n            .build());\n    \n    /**\n     * Aba de Minérios e Blocos - Recursos Naturais\n     * Contém todos os minérios, blocos de armazenamento e blocos da dimensão\n     * \n     * Inclui:\n     * - Minérios Tier 1 e 2\n     * - Blocos de armazenamento\n     * - Blocos da dimensão especial\n     */\n    public static final Supplier<CreativeModeTab> BLOCKS_TAB = CREATIVE_MODE_TABS.register(\"blocks\",\n        () -> CreativeModeTab.builder()\n            .title(Component.translatable(\"itemGroup.cronicasaetherium.blocks\"))\n            .icon(() -> new ItemStack(ModBlocks.AETHERIUM_ORE_ITEM.get()))\n            .displayItems((parameters, output) -> {\n                // TIER 1: Minérios Tecnológicos - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModBlocks.COPPER_ORE_ITEM.get());\n                // output.accept(ModBlocks.DEEPSLATE_COPPER_ORE_ITEM.get());\n                // output.accept(ModBlocks.TIN_ORE_ITEM.get());\n                // output.accept(ModBlocks.DEEPSLATE_TIN_ORE_ITEM.get());\n                // output.accept(ModBlocks.BRONZE_BLOCK_ITEM.get());\n                \n                // TIER 2: Minérios Avançados - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModBlocks.COBALT_ORE_ITEM.get());\n                // output.accept(ModBlocks.DEEPSLATE_COBALT_ORE_ITEM.get());\n                // output.accept(ModBlocks.REINFORCED_STEEL_BLOCK_ITEM.get());\n                \n                // Minérios e Blocos Mágicos - TEMPORARIAMENTE COMENTADO\n                // output.accept(ModBlocks.SOUL_FRAGMENT_CRYSTAL_ITEM.get());\n                \n                // Minérios e Blocos Aetherium Originais\n                output.accept(ModBlocks.AETHERIUM_ORE_ITEM.get());\n                output.accept(ModBlocks.DEEPSLATE_AETHERIUM_ORE_ITEM.get());\n                output.accept(ModBlocks.AETHERIUM_BLOCK_ITEM.get());\n                \n                // Blocos da Dimensão\n                output.accept(ModBlocks.CRYSTALLIZED_SOIL_ITEM.get());\n                output.accept(ModBlocks.DIMENSIONAL_AETHERIUM_ORE_ITEM.get());\n            })\n            .build());\n    \n    /**\n     * Método de registro que deve ser chamado na inicialização do mod\n     * Registra o DeferredRegister no event bus do mod\n     * \n     * @param modEventBus Event bus do mod para registro\n     */\n    public static void register(IEventBus modEventBus) {\n        CREATIVE_MODE_TABS.register(modEventBus);\n    }\n}","size_bytes":13264},"src/main/java/com/cronicasaetherium/mod/registry/ModEntities.java":{"content":"package com.cronicasaetherium.mod.registry;\n\nimport com.cronicasaetherium.mod.CronicasAetherium;\nimport net.minecraft.core.registries.Registries;\nimport net.minecraft.world.entity.EntityType;\nimport net.minecraft.world.entity.MobCategory;\nimport net.neoforged.bus.api.IEventBus;\nimport net.neoforged.neoforge.registries.DeferredRegister;\n\nimport java.util.function.Supplier;\n\n/**\n * Registro central para todas as entidades do mod Crônicas de Aetherium\n * \n * Esta classe gerencia o registro de todas as entidades customizadas do mod,\n * incluindo mobs hostis, neutros, passivos e chefes épicos.\n * \n * Organização das entidades:\n * - Mobs passivos (herbívoros, criaturas mansas)\n * - Mobs neutros (defensivos, territoriais)\n * - Mobs hostis (agressivos, predadores)\n * - Chefes épicos (criaturas lendárias)\n * - Entidades de projétil e utilidade\n * \n * Cada categoria tem comportamentos e sistemas de spawn específicos\n * para incentivar diferentes tipos de exploração e estratégias de combate.\n */\npublic class ModEntities {\n    \n    // DeferredRegister para registro eficiente de entidades\n    public static final DeferredRegister<EntityType<?>> ENTITY_TYPES = \n        DeferredRegister.create(Registries.ENTITY_TYPE, CronicasAetherium.MODID);\n    \n    // ================================\n    // MOBS PASSIVOS - EXPLORAÇÃO PACÍFICA\n    // ================================\n    \n    // TODO: Entidades comentadas temporariamente até implementação das classes\n    /*\n     * Gigante das Planícies - Herbívoro majestoso e gentil\n     * \n     * Características:\n     * - Vagueia pelas planícies em pequenos grupos\n     * - Não ataca mesmo quando provocado\n     * - Dropa couro especial e materiais raros\n     * - Pode ser alimentado com grama especial para obter recursos\n     * \n     * Comportamento:\n     * - Migra entre diferentes áreas de pasto\n     * - Protege filhotes de outros mobs\n     * - Emite sons calmantes que afastam mobs hostis\n     */\n    /*\n    public static final Supplier<EntityType<?>> PLAINS_GIANT = ENTITY_TYPES.register(\"plains_giant\",\n        () -> EntityType.Builder.of(null, MobCategory.CREATURE) // TODO: Implementar classe da entidade\n            .sized(3.0F, 4.0F) // Criatura grande\n            .clientTrackingRange(10)\n            .updateInterval(3)\n            .build(\"plains_giant\"));\n    */\n    \n    /*\n     * Cristal Flutuante - Criatura mágica etérea (TODO: Implementar)\n     */\n    /*\n    public static final Supplier<EntityType<?>> FLOATING_CRYSTAL = ENTITY_TYPES.register(\"floating_crystal\",\n        () -> EntityType.Builder.of(null, MobCategory.AMBIENT)\n            .sized(1.0F, 1.0F)\n            .clientTrackingRange(8)\n            .updateInterval(3)\n            .fireImmune()\n            .build(\"floating_crystal\"));\n    */\n    \n    // ================================\n    // MOBS NEUTROS - EXPLORAÇÃO CAUTELOSA (TODO: Implementar)\n    // ================================\n    \n    /*\n     * Guardião de Ruínas - Defensor ancestral de estruturas (TODO: Implementar)\n     */\n    /*\n    public static final Supplier<EntityType<?>> RUIN_GUARDIAN = ENTITY_TYPES.register(\"ruin_guardian\",\n        () -> EntityType.Builder.of(null, MobCategory.MONSTER)\n            .sized(1.5F, 2.5F)\n            .clientTrackingRange(10)\n            .updateInterval(3)\n            .fireImmune()\n            .build(\"ruin_guardian\"));\n    */\n    \n    // ================================\n    // MOBS HOSTIS - COMBATE E DESAFIO (TODO: Implementar)\n    // ================================\n    \n    /*\n     * TODO: Todas as entidades hostis serão implementadas nas próximas fases\n     * Por enquanto estão comentadas para evitar erros de build\n     */\n    \n    /*\n    public static final Supplier<EntityType<?>> INSECTOID_SWARM = ENTITY_TYPES.register(\"insectoid_swarm\",\n        () -> EntityType.Builder.of(null, MobCategory.MONSTER)\n            .sized(0.8F, 0.6F)\n            .clientTrackingRange(8)\n            .updateInterval(3)\n            .build(\"insectoid_swarm\"));\n    \n    public static final Supplier<EntityType<?>> SHADOW_STALKER = ENTITY_TYPES.register(\"shadow_stalker\",\n        () -> EntityType.Builder.of(null, MobCategory.MONSTER)\n            .sized(1.2F, 2.0F)\n            .clientTrackingRange(12)\n            .updateInterval(3)\n            .build(\"shadow_stalker\"));\n    */\n    \n    // ================================\n    // CHEFES ÉPICOS - BATALHAS MEMORÁVEIS (TODO: Implementar)\n    // ================================\n    \n    /*\n     * TODO: Todos os chefes e projéteis serão implementados nas próximas fases\n     * Por enquanto estão comentados para evitar erros de build\n     */\n    \n    /*\n    public static final Supplier<EntityType<?>> ANCIENT_DRAGON = ENTITY_TYPES.register(\"ancient_dragon\",\n        () -> EntityType.Builder.of(null, MobCategory.MONSTER)\n            .sized(5.0F, 3.0F)\n            .clientTrackingRange(16)\n            .updateInterval(1)\n            .fireImmune()\n            .build(\"ancient_dragon\"));\n    \n    public static final Supplier<EntityType<?>> TECH_COLOSSUS = ENTITY_TYPES.register(\"tech_colossus\",\n        () -> EntityType.Builder.of(null, MobCategory.MONSTER)\n            .sized(6.0F, 8.0F)\n            .clientTrackingRange(20)\n            .updateInterval(1)\n            .fireImmune()\n            .build(\"tech_colossus\"));\n    \n    public static final Supplier<EntityType<?>> VOID_LORD = ENTITY_TYPES.register(\"void_lord\",\n        () -> EntityType.Builder.of(null, MobCategory.MONSTER)\n            .sized(4.0F, 6.0F)\n            .clientTrackingRange(24)\n            .updateInterval(1)\n            .fireImmune()\n            .build(\"void_lord\"));\n    \n    public static final Supplier<EntityType<?>> MAGIC_PROJECTILE = ENTITY_TYPES.register(\"magic_projectile\",\n        () -> EntityType.Builder.of(null, MobCategory.MISC)\n            .sized(0.5F, 0.5F)\n            .clientTrackingRange(4)\n            .updateInterval(20)\n            .build(\"magic_projectile\"));\n    */\n    \n    /**\n     * Método de registro que deve ser chamado na inicialização do mod\n     * Registra o DeferredRegister no event bus do mod\n     * \n     * @param modEventBus Event bus do mod para registro\n     */\n    public static void register(IEventBus modEventBus) {\n        ENTITY_TYPES.register(modEventBus);\n    }\n}","size_bytes":6295},"src/main/java/com/cronicasaetherium/mod/registry/ModItems.java":{"content":"package com.cronicasaetherium.mod.registry;\n\nimport com.cronicasaetherium.mod.CronicasAetherium;\nimport net.minecraft.core.registries.Registries;\nimport net.minecraft.world.item.Item;\nimport net.minecraft.world.item.Rarity;\nimport net.neoforged.bus.api.IEventBus;\nimport net.neoforged.neoforge.registries.DeferredRegister;\nimport com.cronicasaetherium.mod.items.synergy.RuneOfEfficiencyItem;\nimport com.cronicasaetherium.mod.items.lore.WornJournalItem;\nimport com.cronicasaetherium.mod.items.dimension.UnstableHeartItem;\n\nimport java.util.function.Supplier;\n\n/**\n * Registro central para todos os itens do mod Crônicas de Aetherium\n * \n * Esta classe gerencia o registro de todos os itens customizados do mod,\n * incluindo materiais básicos, ferramentas, armaduras e itens mágicos.\n * \n * Organização dos itens:\n * - Materiais básicos (Aetherium, cristais, etc.)\n * - Ferramentas e armas\n * - Componentes de máquinas\n * - Itens mágicos e relíquias\n * - Itens de invocação de chefes\n */\npublic class ModItems {\n    \n    // DeferredRegister para registro eficiente de itens\n    public static final DeferredRegister<Item> ITEMS = \n        DeferredRegister.create(Registries.ITEM, CronicasAetherium.MODID);\n    \n    // ================================\n    // MATERIAIS BÁSICOS E RECURSOS\n    // ================================\n    \n    // ========= MATERIAIS TIER 1: TECNOLOGIA ==========\n    \n    /**\n     * Minério de Cobre Cru - Material básico de tecnologia Tier 1\n     * Encontrado nas camadas médias, base do sistema tecnológico inicial\n     * Usado para criar bronze e componentes básicos\n     */\n    public static final Supplier<Item> RAW_COPPER = ITEMS.register(\"raw_copper\",\n        () -> new Item(new Item.Properties()));\n    \n    /**\n     * Lingote de Cobre - Versão fundida do cobre cru\n     * Primeiro material processado para tecnologia\n     * Componente essencial em todas as receitas de bronze\n     */\n    public static final Supplier<Item> COPPER_INGOT = ITEMS.register(\"copper_ingot\",\n        () -> new Item(new Item.Properties()));\n    \n    /**\n     * Minério de Estanho Cru - Segundo material básico de tecnologia Tier 1  \n     * Mais raro que cobre, essencial para ligas\n     * Encontrado em veios menores nas profundezas médias\n     */\n    public static final Supplier<Item> RAW_TIN = ITEMS.register(\"raw_tin\",\n        () -> new Item(new Item.Properties()));\n    \n    /**\n     * Lingote de Estanho - Versão fundida do estanho cru\n     * Material de liga necessário para criar bronze\n     * Proporção menor nas receitas de bronze\n     */\n    public static final Supplier<Item> TIN_INGOT = ITEMS.register(\"tin_ingot\",\n        () -> new Item(new Item.Properties()));\n    \n    /**\n     * Lingote de Bronze - Primeira liga do mod (Tier 1)\n     * Criado combinando cobre e estanho na proporção correta\n     * Material base para todas as máquinas e ferramentas básicas\n     */\n    public static final Supplier<Item> BRONZE_INGOT = ITEMS.register(\"bronze_ingot\",\n        () -> new Item(new Item.Properties()));\n    \n    /**\n     * Chave de Calibração - Ferramenta essencial de tecnologia\n     * Primeira ferramenta especial que os jogadores devem criar\n     * Usada para configurar e rotacionar máquinas\n     */\n    public static final Supplier<Item> CALIBRATION_WRENCH = ITEMS.register(\"calibration_wrench\",\n        () -> new Item(new Item.Properties()\n            .stacksTo(1)\n            .durability(250)\n            .rarity(Rarity.UNCOMMON)));\n    \n    // ========= MATERIAIS TIER 1: MAGIA ==========\n    \n    /**\n     * Fragmento de Alma - Material mágico básico Tier 1\n     * Encontrado no subsolo, pulsa com luz fraca\n     * Base para toda a progressão mágica inicial\n     */\n    public static final Supplier<Item> SOUL_FRAGMENT = ITEMS.register(\"soul_fragment\",\n        () -> new Item(new Item.Properties()\n            .rarity(Rarity.UNCOMMON)));\n    \n    /**\n     * Essência Espiritual - Combustível mágico básico\n     * Dropado por mobs mortos com Faca de Sacrifício\n     * Consumido em todas as transmutações mágicas básicas\n     */\n    public static final Supplier<Item> SPIRIT_ESSENCE = ITEMS.register(\"spirit_essence\",\n        () -> new Item(new Item.Properties()\n            .rarity(Rarity.COMMON)));\n    \n    /**\n     * Faca de Sacrifício - Ferramenta mágica para colheita de essências\n     * Primeira ferramenta mágica especial\n     * Mata mobs e tem chance de dropar Essência Espiritual\n     */\n    public static final Supplier<Item> SACRIFICE_KNIFE = ITEMS.register(\"sacrifice_knife\",\n        () -> new Item(new Item.Properties()\n            .stacksTo(1)\n            .durability(150)\n            .rarity(Rarity.UNCOMMON)));\n    \n    // ========= MATERIAIS TIER 2: TECNOLOGIA ==========\n    \n    /**\n     * Minério de Cobalto Cru - Material avançado Tier 2\n     * Encontrado em veios raros no subsolo profundo\n     * Necessário para criar Aço Reforçado\n     */\n    public static final Supplier<Item> RAW_COBALT = ITEMS.register(\"raw_cobalt\",\n        () -> new Item(new Item.Properties()\n            .rarity(Rarity.RARE)));\n    \n    /**\n     * Lingote de Cobalto - Versão fundida do cobalto cru  \n     * Material raro para ligas avançadas\n     * Componente do Aço Reforçado junto com ferro\n     */\n    public static final Supplier<Item> COBALT_INGOT = ITEMS.register(\"cobalt_ingot\",\n        () -> new Item(new Item.Properties()\n            .rarity(Rarity.RARE)));\n    \n    /**\n     * Lingote de Aço Reforçado - Liga avançada Tier 2\n     * Criado combinando Ferro + Cobalto + FE na Fundidora de Ligas\n     * Material principal para todas as máquinas Tier 2\n     */\n    public static final Supplier<Item> REINFORCED_STEEL_INGOT = ITEMS.register(\"reinforced_steel_ingot\",\n        () -> new Item(new Item.Properties()\n            .rarity(Rarity.RARE)));\n    \n    // ========= MATERIAIS DE MINI-BOSS ==========\n    \n    /**\n     * Coração de Adamantina - Drop do Colosso de Rocha (mini-boss)\n     * Item raro necessário para rituais avançados e máquinas Tier 2+\n     * Só pode ser obtido derrotando o primeiro mini-boss\n     */\n    public static final Supplier<Item> ADAMANTINE_HEART = ITEMS.register(\"adamantine_heart\",\n        () -> new Item(new Item.Properties()\n            .stacksTo(1)\n            .rarity(Rarity.EPIC)));\n    \n    // ========= MATERIAIS TIER 2: MAGIA ==========\n    \n    /**\n     * Espírito Maligno - Essência de mobs hostis\n     * Dropado por mobs agressivos mortos com Faca de Sacrifício\n     * Usado em rituais de combate e encantamentos ofensivos\n     */\n    public static final Supplier<Item> MALIGNANT_SPIRIT = ITEMS.register(\"malignant_spirit\",\n        () -> new Item(new Item.Properties()\n            .rarity(Rarity.UNCOMMON)));\n    \n    /**\n     * Espírito Puro - Essência de mobs pacíficos\n     * Dropado por mobs passivos mortos com Faca de Sacrifício\n     * Usado em rituais de proteção e encantamentos defensivos\n     */\n    public static final Supplier<Item> PURE_SPIRIT = ITEMS.register(\"pure_spirit\",\n        () -> new Item(new Item.Properties()\n            .rarity(Rarity.UNCOMMON)));\n    \n    /**\n     * Espírito Arcano - Essência de mobs mágicos\n     * Dropado por criaturas mágicas mortas com Faca de Sacrifício\n     * Material mais raro, usado em rituais avançados\n     */\n    public static final Supplier<Item> ARCANE_SPIRIT = ITEMS.register(\"arcane_spirit\",\n        () -> new Item(new Item.Properties()\n            .rarity(Rarity.RARE)));\n    \n    /**\n     * Essência Mágica Concentrada - Versão refinada da essência básica\n     * Criada através de rituais no Altar de Infusão\n     * Necessária para encantamentos permanentes e artefatos\n     */\n    public static final Supplier<Item> CONCENTRATED_MAGIC_ESSENCE = ITEMS.register(\"concentrated_magic_essence\",\n        () -> new Item(new Item.Properties()\n            .rarity(Rarity.RARE)));\n    \n    /**\n     * Cristal de Aetherium - Material base do mod\n     * Obtido através de mineração em estruturas especiais\n     * Usado como componente principal em receitas avançadas\n     */\n    public static final Supplier<Item> AETHERIUM_CRYSTAL = ITEMS.register(\"aetherium_crystal\",\n        () -> new Item(new Item.Properties()));\n    \n    /**\n     * Fragmento de Aetherium - Versão refinada do cristal\n     * Obtido através de processamento tecnológico\n     * Necessário para itens de alto nível\n     */\n    public static final Supplier<Item> AETHERIUM_FRAGMENT = ITEMS.register(\"aetherium_fragment\",\n        () -> new Item(new Item.Properties()));\n    \n    /**\n     * Essência Mágica - Recurso base para o sistema de magia\n     * Obtida através de rituais e processamento de plantas mágicas\n     * Consumida na criação de feitiços e itens mágicos\n     */\n    public static final Supplier<Item> MAGIC_ESSENCE = ITEMS.register(\"magic_essence\",\n        () -> new Item(new Item.Properties()));\n    \n    // ================================\n    // AMULETOS E ITENS FUNCIONAIS\n    // ================================\n    \n    // ========= AMULETOS TIER 1: MAGIA ==========\n    \n    /**\n     * Amuleto de Penumbra - Primeiro amuleto funcional Tier 1\n     * Reduz o alcance de detecção de monstros na escuridão\n     * Facilita exploração noturna e em cavernas escuras\n     */\n    public static final Supplier<Item> PENUMBRA_AMULET = ITEMS.register(\"penumbra_amulet\",\n        () -> new Item(new Item.Properties()\n            .stacksTo(1)\n            .rarity(Rarity.UNCOMMON)));\n    \n    /**\n     * Anel de Caçador - Segundo item funcional Tier 1\n     * Faz inimigos atingidos brilharem através das paredes\n     * Útil para rastrear mobs após combate inicial\n     */\n    public static final Supplier<Item> HUNTER_RING = ITEMS.register(\"hunter_ring\",\n        () -> new Item(new Item.Properties()\n            .stacksTo(1)\n            .rarity(Rarity.UNCOMMON)));\n    \n    /**\n     * Códice Escondido - Guia mágico Tier 1\n     * Criado com livro + Fragmento de Alma\n     * Revela novos conhecimentos mágicos conforme progressão\n     */\n    public static final Supplier<Item> HIDDEN_CODEX = ITEMS.register(\"hidden_codex\",\n        () -> new Item(new Item.Properties()\n            .stacksTo(1)\n            .rarity(Rarity.RARE)));\n    \n    // ========= FERRAMENTAS MÁGICAS TIER 1 ==========\n    \n    /**\n     * Varinha da Floresta - Ferramenta de ativação mágica\n     * Usada para ativar rituais no Altar Arcano\n     * Ferramenta essencial para progressão mágica Tier 2\n     */\n    public static final Supplier<Item> FOREST_WAND = ITEMS.register(\"forest_wand\",\n        () -> new Item(new Item.Properties()\n            .stacksTo(1)\n            .durability(100)\n            .rarity(Rarity.UNCOMMON)));\n    \n    // ========= ARTEFATOS TIER 2: SINERGIA ==========\n    \n    /**\n     * Anel de Regeneração - Item funcional mágico Tier 2\n     * Consome mana do inventário para regenerar vida lentamente\n     * Exemplo de magia funcional para sobrevivência\n     */\n    public static final Supplier<Item> REGENERATION_RING = ITEMS.register(\"regeneration_ring\",\n        () -> new Item(new Item.Properties()\n            .stacksTo(1)\n            .rarity(Rarity.RARE)));\n    \n    /**\n     * Núcleo Anímico - Item Tier 3 para criação de golens\n     * Criado no Altar de Infusão com materiais raros\n     * Permite criar golems mágicos assistentes\n     */\n    public static final Supplier<Item> ANIMIC_CORE = ITEMS.register(\"animic_core\",\n        () -> new Item(new Item.Properties()\n            .stacksTo(1)\n            .rarity(Rarity.EPIC)));\n    \n    // ========= BOLSAS E ARMAZENAMENTO ==========\n    \n    /**\n     * Bolsa de Espíritos - Armazenamento especializado Tier 2\n     * Armazena e separa diferentes tipos de espíritos colhidos\n     * Essencial para magia avançada organizada\n     */\n    public static final Supplier<Item> SPIRIT_POUCH = ITEMS.register(\"spirit_pouch\",\n        () -> new Item(new Item.Properties()\n            .stacksTo(1)\n            .rarity(Rarity.UNCOMMON)));\n    \n    // ========= COMPONENTES TIER 1 TECNOLOGIA ==========\n    \n    /**\n     * Engrenagem de Bronze - Componente básico Tier 1\n     * Criada na Prensa de Engrenagens com lingotes de bronze\n     * Usada em todas as máquinas Tier 1\n     */\n    public static final Supplier<Item> BRONZE_GEAR = ITEMS.register(\"bronze_gear\",\n        () -> new Item(new Item.Properties()));\n    \n    /**\n     * Placa de Bronze - Componente estrutural Tier 1\n     * Criada na Prensa de Engrenagens \n     * Material de construção para máquinas\n     */\n    public static final Supplier<Item> BRONZE_PLATE = ITEMS.register(\"bronze_plate\",\n        () -> new Item(new Item.Properties()));\n    \n    /**\n     * Pó de Cobre - Material processado\n     * Resultado do Triturador Mecânico processando minério de cobre\n     * Dobra o rendimento de cobre quando fundido\n     */\n    public static final Supplier<Item> COPPER_DUST = ITEMS.register(\"copper_dust\",\n        () -> new Item(new Item.Properties()));\n    \n    /**\n     * Pó de Estanho - Material processado\n     * Resultado do Triturador Mecânico processando minério de estanho\n     * Dobra o rendimento de estanho quando fundido  \n     */\n    public static final Supplier<Item> TIN_DUST = ITEMS.register(\"tin_dust\",\n        () -> new Item(new Item.Properties()));\n    \n    // ========= COMPONENTES TIER 2 TECNOLOGIA ==========\n    \n    /**\n     * Engrenagem de Aço Reforçado - Componente avançado Tier 2\n     * Criada com Aço Reforçado para máquinas de alta performance\n     * Essencial para automação avançada\n     */\n    public static final Supplier<Item> REINFORCED_STEEL_GEAR = ITEMS.register(\"reinforced_steel_gear\",\n        () -> new Item(new Item.Properties()\n            .rarity(Rarity.RARE)));\n    \n    /**\n     * Circuito de Aprimoramento: Velocidade - Módulo Tier 2\n     * Pode ser instalado em máquinas para aumentar velocidade\n     * Sistema modular de otimização de máquinas\n     */\n    public static final Supplier<Item> SPEED_UPGRADE_CIRCUIT = ITEMS.register(\"speed_upgrade_circuit\",\n        () -> new Item(new Item.Properties()\n            .stacksTo(16)\n            .rarity(Rarity.UNCOMMON)));\n    \n    /**\n     * Circuito de Aprimoramento: Eficiência - Módulo Tier 2\n     * Reduz consumo de energia das máquinas\n     * Otimização de energia para produção sustentável\n     */\n    public static final Supplier<Item> EFFICIENCY_UPGRADE_CIRCUIT = ITEMS.register(\"efficiency_upgrade_circuit\",\n        () -> new Item(new Item.Properties()\n            .stacksTo(16)\n            .rarity(Rarity.UNCOMMON)));\n    \n    /**\n     * Circuito de Aprimoramento: Sorte - Módulo Tier 2\n     * Adiciona efeito Fortune às máquinas de processamento\n     * Aumenta rendimento de materiais processados\n     */\n    public static final Supplier<Item> FORTUNE_UPGRADE_CIRCUIT = ITEMS.register(\"fortune_upgrade_circuit\",\n        () -> new Item(new Item.Properties()\n            .stacksTo(16)\n            .rarity(Rarity.RARE)));\n\n    // ================================\n    // COMPONENTES TECNOLÓGICOS\n    // ================================\n    \n    /**\n     * Engrenagem de Aetherium - Componente básico para máquinas\n     * Crafted combinando Aetherium com ferro\n     * Usado em todas as máquinas rotacionais\n     */\n    public static final Supplier<Item> AETHERIUM_GEAR = ITEMS.register(\"aetherium_gear\",\n        () -> new Item(new Item.Properties()));\n    \n    /**\n     * Circuito Mágico - Componente avançado que une tecnologia e magia\n     * Necessário para máquinas que processam energia mágica\n     * Requer tanto materiais tecnológicos quanto mágicos\n     */\n    public static final Supplier<Item> MAGIC_CIRCUIT = ITEMS.register(\"magic_circuit\",\n        () -> new Item(new Item.Properties()));\n    \n    // ================================\n    // ITENS DE INVOCAÇÃO DE CHEFES\n    // ================================\n    \n    /**\n     * Amuleto do Dragão Ancestral - Invoca o primeiro chefe\n     * Craftado com materiais raros encontrados em estruturas antigas\n     * Uso único, consome o item ao invocar o chefe\n     */\n    public static final Supplier<Item> ANCIENT_DRAGON_AMULET = ITEMS.register(\"ancient_dragon_amulet\",\n        () -> new Item(new Item.Properties().stacksTo(1)));\n    \n    /**\n     * Núcleo Corrompido - Invoca o chefe tecnológico\n     * Obtido através de processamento avançado de materiais corrompidos\n     * Deve ser usado em uma estrutura específica\n     */\n    public static final Supplier<Item> CORRUPTED_CORE = ITEMS.register(\"corrupted_core\",\n        () -> new Item(new Item.Properties().stacksTo(1)));\n    \n    /**\n     * Orbe do Vazio - Invoca o chefe mágico final\n     * Item mais raro do mod, requer materiais de todos os sistemas\n     * Só pode ser usado após derrotar os outros dois chefes\n     */\n    public static final Supplier<Item> VOID_ORB = ITEMS.register(\"void_orb\",\n        () -> new Item(new Item.Properties().stacksTo(1)));\n    \n    // ================================\n    // ITENS DA DIMENSÃO CRISOL ARCANO\n    // ================================\n    \n    /**\n     * Coração Instável - Ativador do portal para a dimensão Crisol Arcano\n     * Item raro usado para ativar a estrutura do portal arcano\n     * Consumido durante a ativação do portal\n     */\n    public static final Supplier<Item> UNSTABLE_HEART = ITEMS.register(\"unstable_heart\",\n        () -> new UnstableHeartItem(new Item.Properties().stacksTo(1)));\n    \n    // ================================\n    // ITENS DE SINERGIA (TECNOLOGIA + MAGIA)\n    // ================================\n    \n    /**\n     * Runa de Eficiência - Item de sinergia Magia → Tecnologia\n     * Aplicada em máquinas para conceder bônus de eficiência\n     * Consome o item ao usar, efeito permanente na máquina\n     */\n    public static final Supplier<Item> RUNE_OF_EFFICIENCY = ITEMS.register(\"rune_of_efficiency\",\n        () -> new RuneOfEfficiencyItem(new Item.Properties()\n            .stacksTo(16)\n            .rarity(Rarity.UNCOMMON)));\n    \n    // ================================\n    // LIVROS E GUIAS\n    // ================================\n    \n    /**\n     * Tomo das Crônicas - Livro guia principal do mod\n     * Contém todas as informações necessárias para progressão\n     * Recebido automaticamente quando o jogador primeiro encontra um material do mod\n     */\n    public static final Supplier<Item> CHRONICLES_TOME = ITEMS.register(\"chronicles_tome\",\n        () -> new Item(new Item.Properties().stacksTo(1)));\n    \n    /**\n     * Diário Desgastado - Item de lore introdutório\n     * Contém fragmentos da história e lore do mod\n     * Abre interface com textos introdutórios quando usado\n     */\n    public static final Supplier<Item> WORN_JOURNAL = ITEMS.register(\"worn_journal\",\n        () -> new WornJournalItem(new Item.Properties()\n            .stacksTo(1)\n            .rarity(Rarity.UNCOMMON)));\n    \n    /**\n     * Método de registro que deve ser chamado na inicialização do mod\n     * Registra o DeferredRegister no event bus do mod\n     * \n     * @param modEventBus Event bus do mod para registro\n     */\n    public static void register(IEventBus modEventBus) {\n        ITEMS.register(modEventBus);\n    }\n}","size_bytes":19236},"src/main/java/com/cronicasaetherium/mod/blocks/synergy/ArcanePortalBlock.java":{"content":"package com.cronicasaetherium.mod.blocks.synergy;\n\nimport com.cronicasaetherium.mod.registry.ModItems;\nimport com.cronicasaetherium.mod.world.dimension.ModDimensions;\nimport net.minecraft.core.BlockPos;\nimport net.minecraft.server.level.ServerLevel;\nimport net.minecraft.server.level.ServerPlayer;\nimport net.minecraft.world.InteractionResult;\nimport net.minecraft.world.entity.player.Player;\nimport net.minecraft.world.item.ItemStack;\nimport net.minecraft.world.level.Level;\nimport net.minecraft.world.level.block.Block;\nimport net.minecraft.world.level.block.state.BlockBehaviour;\nimport net.minecraft.world.level.block.state.BlockState;\nimport net.minecraft.world.phys.BlockHitResult;\n\n/**\n * Bloco de Portal Ativo do Crisol Arcano\n * \n * Este bloco representa o portal ativo para a dimensão do Crisol Arcano.\n * É criado temporariamente quando o jogador ativa a estrutura do portal\n * com o Coração Instável.\n * \n * Funcionalidades:\n * - Teleporta jogadores para a dimensão Crisol Arcano\n * - Efeitos visuais de portal ativo\n * - Sistema de cooldown para prevenir uso excessivo\n * - Integração com sistema de proficiência arcana\n */\npublic class ArcanePortalBlock extends Block {\n    \n    /**\n     * Construtor do bloco de portal ativo\n     * \n     * @param properties Propriedades do bloco\n     */\n    public ArcanePortalBlock(BlockBehaviour.Properties properties) {\n        super(properties);\n    }\n    \n    /**\n     * Manipula a interação do jogador com o portal\n     * \n     * Quando o jogador clica no portal ativo, verifica se pode viajar\n     * e realiza a teleportação para a dimensão apropriada.\n     * \n     * @param state Estado do bloco\n     * @param level Nível/mundo atual\n     * @param pos Posição do portal\n     * @param player Jogador que interagiu\n     * @param hit Informações do clique\n     * @return Resultado da interação\n     */\n    @Override\n    protected InteractionResult useWithoutItem(BlockState state, Level level, BlockPos pos, Player player, BlockHitResult hit) {\n        if (!level.isClientSide() && player instanceof ServerPlayer serverPlayer) {\n            return attemptTeleportation(serverPlayer, level, pos);\n        }\n        return InteractionResult.SUCCESS;\n    }\n    \n    /**\n     * Tenta realizar a teleportação do jogador\n     * \n     * @param player Jogador a teleportar\n     * @param level Nível atual\n     * @param portalPos Posição do portal\n     * @return Resultado da tentativa\n     */\n    private InteractionResult attemptTeleportation(ServerPlayer player, Level level, BlockPos portalPos) {\n        // Verifica cooldown do jogador (implementação básica)\n        // TODO: Integrar com sistema de configuração para cooldown real\n        \n        // Determina a dimensão de destino\n        Level targetLevel;\n        if (level.dimension() == Level.OVERWORLD) {\n            // Do Overworld para Crisol Arcano\n            targetLevel = level.getServer().getLevel(ModDimensions.ARCANE_CRUCIBLE);\n            if (targetLevel == null) {\n                player.sendSystemMessage(net.minecraft.network.chat.Component.literal(\n                    \"§cErro: Dimensão Crisol Arcano não está disponível!\"));\n                return InteractionResult.FAIL;\n            }\n        } else if (level.dimension() == ModDimensions.ARCANE_CRUCIBLE) {\n            // Do Crisol Arcano de volta ao Overworld\n            targetLevel = level.getServer().getLevel(Level.OVERWORLD);\n        } else {\n            // Dimensão não suportada\n            player.sendSystemMessage(net.minecraft.network.chat.Component.literal(\n                \"§cEste portal não pode ser usado nesta dimensão!\"));\n            return InteractionResult.FAIL;\n        }\n        \n        // Calcula posição de destino\n        BlockPos targetPos = calculateTargetPosition(portalPos, targetLevel);\n        \n        // Realiza a teleportação\n        performTeleportation(player, (ServerLevel) targetLevel, targetPos);\n        \n        return InteractionResult.SUCCESS;\n    }\n    \n    /**\n     * Calcula a posição de destino na dimensão alvo\n     * \n     * @param portalPos Posição do portal de origem\n     * @param targetLevel Nível de destino\n     * @return Posição segura para teleportação\n     */\n    private BlockPos calculateTargetPosition(BlockPos portalPos, Level targetLevel) {\n        // TODO: Implementar lógica mais sofisticada de posicionamento\n        // Por ora, usa a mesma posição relativa\n        BlockPos targetPos = new BlockPos(portalPos.getX(), 100, portalPos.getZ());\n        \n        // Encontra uma posição segura\n        for (int y = 100; y > 60; y--) {\n            BlockPos testPos = new BlockPos(targetPos.getX(), y, targetPos.getZ());\n            if (targetLevel.getBlockState(testPos).isAir() && \n                targetLevel.getBlockState(testPos.above()).isAir() &&\n                !targetLevel.getBlockState(testPos.below()).isAir()) {\n                return testPos;\n            }\n        }\n        \n        return targetPos; // Fallback para posição original\n    }\n    \n    /**\n     * Executa a teleportação do jogador\n     * \n     * @param player Jogador a teleportar\n     * @param targetLevel Nível de destino\n     * @param targetPos Posição de destino\n     */\n    private void performTeleportation(ServerPlayer player, ServerLevel targetLevel, BlockPos targetPos) {\n        // Efeitos sonoros e visuais antes da teleportação\n        player.level().playSound(null, player.blockPosition(), \n            net.minecraft.sounds.SoundEvents.ENDERMAN_TELEPORT, \n            net.minecraft.sounds.SoundSource.PLAYERS, 1.0f, 1.0f);\n        \n        // Teleporta o jogador\n        player.teleportTo(targetLevel, \n            targetPos.getX() + 0.5, \n            targetPos.getY(), \n            targetPos.getZ() + 0.5, \n            player.getYRot(), \n            player.getXRot());\n        \n        // Mensagem de confirmação\n        String dimensionName = targetLevel.dimension() == ModDimensions.ARCANE_CRUCIBLE ? \n            \"Crisol Arcano\" : \"Mundo Superior\";\n        \n        player.sendSystemMessage(net.minecraft.network.chat.Component.literal(\n            \"§5✨ Teleportado para: \" + dimensionName));\n        \n        // TODO: Adicionar XP de proficiência arcana pela viagem dimensional\n        // ModCapabilities.ifPlayerProficiencyPresent(player, proficiency -> {\n        //     proficiency.addArcanaXp(ModConfig.BASE_ARCANA_XP.get());\n        // });\n    }\n}","size_bytes":6460},"src/main/java/com/cronicasaetherium/mod/blocks/synergy/ManaInfuserBlock.java":{"content":"package com.cronicasaetherium.mod.blocks.synergy;\n\nimport com.cronicasaetherium.mod.blocks.synergy.ManaInfuserBlockEntity;\nimport net.minecraft.core.BlockPos;\nimport net.minecraft.server.level.ServerPlayer;\nimport net.minecraft.world.InteractionResult;\nimport net.minecraft.world.entity.player.Player;\nimport net.minecraft.world.level.Level;\nimport net.minecraft.world.level.block.BaseEntityBlock;\nimport net.minecraft.world.level.block.RenderShape;\nimport net.minecraft.world.level.block.entity.BlockEntity;\nimport net.minecraft.world.level.block.entity.BlockEntityTicker;\nimport net.minecraft.world.level.block.entity.BlockEntityType;\nimport net.minecraft.world.level.block.state.BlockBehaviour;\nimport net.minecraft.world.level.block.state.BlockState;\nimport net.minecraft.world.phys.BlockHitResult;\nimport org.jetbrains.annotations.Nullable;\n\n/**\n * Infusora de Mana - Máquina de sinergia Tecnologia → Magia\n * \n * Esta máquina representa a ponte entre os sistemas tecnológicos e mágicos do mod.\n * Ela converte energia tecnológica (Forge Energy) em mana utilizável pelo sistema mágico.\n * \n * Funcionalidades:\n * - Aceita energia elétrica como entrada\n * - Processa catalisadores mágicos (flores, essências)\n * - Produz mana líquida ou cristalizada\n * - Interface gráfica para monitoramento\n * - Integração com ambos os sistemas de progressão\n * \n * A máquina é fundamental para jogadores que focam em tecnologia mas querem\n * acessar alguns benefícios do sistema mágico, promovendo sinergia entre os paths.\n */\npublic class ManaInfuserBlock extends BaseEntityBlock {\n    \n    /**\n     * Construtor da Infusora de Mana\n     * Define as propriedades físicas e comportamentais do bloco\n     * \n     * @param properties Propriedades do bloco (resistência, som, etc.)\n     */\n    public ManaInfuserBlock(BlockBehaviour.Properties properties) {\n        super(properties);\n    }\n    \n    /**\n     * Cria a entidade do bloco (BlockEntity) responsável pela lógica da máquina\n     * \n     * @param pos Posição do bloco no mundo\n     * @param state Estado atual do bloco\n     * @return Nova instância da BlockEntity da Infusora de Mana\n     */\n    @Nullable\n    @Override\n    public BlockEntity newBlockEntity(BlockPos pos, BlockState state) {\n        return new ManaInfuserBlockEntity(pos, state);\n    }\n    \n    /**\n     * Configura o ticker da BlockEntity para processar lógica contínua\n     * \n     * O ticker é executado a cada tick do jogo quando a máquina está ativa,\n     * permitindo que ela processe energia, consuma itens e produza mana.\n     * \n     * @param level Nível/mundo onde está o bloco\n     * @param state Estado do bloco\n     * @param blockEntityType Tipo da BlockEntity\n     * @return Ticker configurado ou null se não houver processamento\n     */\n    @Nullable\n    @Override\n    public <T extends BlockEntity> BlockEntityTicker<T> getTicker(Level level, BlockState state, BlockEntityType<T> blockEntityType) {\n        if (!level.isClientSide()) {\n            return (lvl, pos, st, blockEntity) -> {\n                if (blockEntity instanceof ManaInfuserBlockEntity manaInfuser) {\n                    manaInfuser.tick();\n                }\n            };\n        }\n        return null;\n    }\n    \n    /**\n     * Manipula a interação do jogador com a máquina\n     * \n     * Quando o jogador clica com o botão direito na máquina,\n     * abre a interface gráfica para gerenciar entrada, saída e energia.\n     * \n     * @param state Estado do bloco\n     * @param level Nível/mundo\n     * @param pos Posição do bloco\n     * @param player Jogador que interagiu\n     * @param hit Informações sobre onde o jogador clicou\n     * @return Resultado da interação\n     */\n    @Override\n    protected InteractionResult useWithoutItem(BlockState state, Level level, BlockPos pos, Player player, BlockHitResult hit) {\n        if (!level.isClientSide()) {\n            BlockEntity blockEntity = level.getBlockEntity(pos);\n            if (blockEntity instanceof ManaInfuserBlockEntity manaInfuser && player instanceof ServerPlayer serverPlayer) {\n                // Mensagem informativa sobre o estado da máquina\n                String status = manaInfuser.isProcessing() ? \"§aProcessando\" : \"§7Inativa\";\n                int energy = manaInfuser.getEnergyStored();\n                int maxEnergy = manaInfuser.getMaxEnergy();\n                int progress = manaInfuser.getProcessProgress();\n                \n                player.sendSystemMessage(net.minecraft.network.chat.Component.literal(\n                    String.format(\"§6Infusora de Mana - Status: %s§r\", status)));\n                player.sendSystemMessage(net.minecraft.network.chat.Component.literal(\n                    String.format(\"§eEnergia: %d/%d FE\", energy, maxEnergy)));\n                if (manaInfuser.isProcessing()) {\n                    player.sendSystemMessage(net.minecraft.network.chat.Component.literal(\n                        String.format(\"§bProgresso: %d%%\", progress)));\n                }\n                \n                return InteractionResult.SUCCESS;\n            }\n        }\n        return InteractionResult.sidedSuccess(level.isClientSide());\n    }\n    \n    /**\n     * Define como o bloco deve ser renderizado\n     * \n     * @param state Estado do bloco\n     * @return Tipo de renderização (modelo 3D normal)\n     */\n    @Override\n    protected RenderShape getRenderShape(BlockState state) {\n        return RenderShape.MODEL;\n    }\n    \n    /**\n     * Comportamento quando o bloco é removido\n     * \n     * Garante que os itens no inventário da máquina sejam dropados\n     * e que a BlockEntity seja adequadamente limpa.\n     * \n     * @param state Estado do bloco sendo removido\n     * @param level Nível/mundo\n     * @param pos Posição do bloco\n     * @param newState Novo estado que substitui o bloco\n     * @param movedByPiston Se o bloco foi movido por um pistão\n     */\n    @Override\n    public void onRemove(BlockState state, Level level, BlockPos pos, BlockState newState, boolean movedByPiston) {\n        if (!state.is(newState.getBlock())) {\n            BlockEntity blockEntity = level.getBlockEntity(pos);\n            if (blockEntity instanceof ManaInfuserBlockEntity manaInfuser) {\n                // TODO: Dropar itens do inventário quando implementado\n                // manaInfuser.dropInventoryContents(level, pos);\n            }\n            super.onRemove(state, level, pos, newState, movedByPiston);\n        }\n    }\n}","size_bytes":6491},"src/main/java/com/cronicasaetherium/mod/blocks/synergy/ManaInfuserBlockEntity.java":{"content":"package com.cronicasaetherium.mod.blocks.synergy;\n\nimport com.cronicasaetherium.mod.CronicasAetherium;\nimport com.cronicasaetherium.mod.registry.ModBlockEntities;\nimport net.minecraft.core.BlockPos;\nimport net.minecraft.core.HolderLookup;\nimport net.minecraft.nbt.CompoundTag;\nimport net.minecraft.world.level.block.entity.BlockEntity;\nimport net.minecraft.world.level.block.entity.BlockEntityType;\nimport net.minecraft.world.level.block.state.BlockState;\n\n/**\n * BlockEntity da Infusora de Mana - Lógica de processamento da máquina\n * \n * Esta classe implementa toda a lógica interna da Infusora de Mana,\n * incluindo armazenamento de energia, processamento de itens e geração de mana.\n * \n * Sistemas integrados:\n * - Armazenamento de Forge Energy para energia de entrada\n * - Inventário para catalisadores (entrada) e produtos (saída)  \n * - Sistema de receitas para conversão de energia em mana\n * - Sincronização client-server para atualizações de GUI\n * - Persistência de dados via NBT\n * \n * Esta BlockEntity serve como exemplo de como integrar sistemas tecnológicos\n * e mágicos de forma que ambos os tipos de jogador possam se beneficiar.\n */\npublic class ManaInfuserBlockEntity extends BlockEntity {\n    \n    // Constantes de configuração da máquina\n    private static final int MAX_ENERGY = 10000; // Capacidade máxima de energia\n    private static final int ENERGY_PER_OPERATION = 100; // Energia consumida por operação\n    private static final int PROCESSING_TIME = 100; // Ticks para completar uma operação\n    \n    // Estado interno da máquina\n    private int energyStored = 0; // Energia atualmente armazenada\n    private int processProgress = 0; // Progresso da operação atual (0-100)\n    private boolean isProcessing = false; // Se a máquina está processando\n    \n    // TODO: Adicionar quando o sistema de inventário for implementado\n    // private final ItemStackHandler inventory = new ItemStackHandler(3) {\n    //     @Override\n    //     protected void onContentsChanged(int slot) {\n    //         setChanged(); // Marca a BlockEntity como modificada\n    //         sync(); // Sincroniza com o cliente\n    //     }\n    // };\n    \n    /**\n     * Construtor da BlockEntity\n     * \n     * @param type Tipo da BlockEntity (registrado no ModBlockEntities)\n     * @param pos Posição no mundo\n     * @param state Estado do bloco\n     */\n    public ManaInfuserBlockEntity(BlockEntityType<?> type, BlockPos pos, BlockState state) {\n        super(type, pos, state);\n    }\n    \n    /**\n     * Construtor simplificado usando o tipo registrado\n     * \n     * @param pos Posição no mundo\n     * @param state Estado do bloco\n     */\n    public ManaInfuserBlockEntity(BlockPos pos, BlockState state) {\n        this(ModBlockEntities.MANA_INFUSER.get(), pos, state);\n    }\n    \n    /**\n     * Método principal de processamento - executado a cada tick\n     * \n     * Este método gerencia toda a lógica da máquina:\n     * - Verifica se há energia suficiente\n     * - Processa catalisadores se houver\n     * - Atualiza progresso e estado\n     * - Consome energia conforme necessário\n     */\n    public void tick() {\n        if (level == null || level.isClientSide()) {\n            return; // Processa apenas no servidor\n        }\n        \n        boolean wasProcessing = isProcessing;\n        \n        // Verifica se pode iniciar ou continuar processamento\n        if (canProcess()) {\n            if (!isProcessing) {\n                startProcessing();\n            }\n            \n            continueProcessing();\n        } else {\n            stopProcessing();\n        }\n        \n        // Sincroniza com o cliente se o estado mudou\n        if (wasProcessing != isProcessing) {\n            setChanged();\n            syncToClient();\n        }\n        \n        // TODO: Implementar lógica de geração de Mana quando o sistema for adicionado\n        // if (processProgress >= PROCESSING_TIME) {\n        //     generateMana();\n        //     completeProcessing();\n        // }\n    }\n    \n    /**\n     * Verifica se a máquina pode processar\n     * \n     * @return true se pode processar, false caso contrário\n     */\n    private boolean canProcess() {\n        // Verifica energia suficiente\n        if (energyStored < ENERGY_PER_OPERATION) {\n            return false;\n        }\n        \n        // TODO: Verificar se há catalisadores no slot de entrada\n        // TODO: Verificar se há espaço no slot de saída\n        \n        return true; // Temporariamente sempre true para testes\n    }\n    \n    /**\n     * Inicia um novo processo de conversão\n     */\n    private void startProcessing() {\n        isProcessing = true;\n        processProgress = 0;\n        \n        CronicasAetherium.LOGGER.debug(\"Infusora de Mana iniciou processamento na posição {}\", getBlockPos());\n    }\n    \n    /**\n     * Continua o processo atual\n     */\n    private void continueProcessing() {\n        processProgress++;\n        \n        // Consome energia gradualmente durante o processo\n        if (processProgress % 10 == 0) { // A cada 10 ticks\n            consumeEnergy(ENERGY_PER_OPERATION / 10);\n        }\n        \n        // Completa o processo quando atinge o tempo necessário\n        if (processProgress >= PROCESSING_TIME) {\n            completeProcessing();\n        }\n    }\n    \n    /**\n     * Para o processamento atual\n     */\n    private void stopProcessing() {\n        if (isProcessing) {\n            isProcessing = false;\n            processProgress = 0;\n            \n            CronicasAetherium.LOGGER.debug(\"Infusora de Mana parou processamento na posição {}\", getBlockPos());\n        }\n    }\n    \n    /**\n     * Completa um ciclo de processamento\n     */\n    private void completeProcessing() {\n        // TODO: Implementar geração de mana quando o sistema for adicionado\n        CronicasAetherium.LOGGER.info(\"Infusora de Mana completou um ciclo na posição {}\", getBlockPos());\n        \n        // Reseta para o próximo ciclo\n        processProgress = 0;\n        \n        // Continua processando se ainda há recursos\n        if (!canProcess()) {\n            stopProcessing();\n        }\n    }\n    \n    /**\n     * Consome energia da máquina\n     * \n     * @param amount Quantidade de energia a consumir\n     */\n    private void consumeEnergy(int amount) {\n        energyStored = Math.max(0, energyStored - amount);\n    }\n    \n    /**\n     * Adiciona energia à máquina\n     * \n     * @param amount Quantidade de energia a adicionar\n     * @return Quantidade efetivamente adicionada\n     */\n    public int addEnergy(int amount) {\n        int addable = Math.min(amount, MAX_ENERGY - energyStored);\n        energyStored += addable;\n        setChanged();\n        return addable;\n    }\n    \n    /**\n     * Obtém a energia atualmente armazenada\n     * \n     * @return Energia armazenada\n     */\n    public int getEnergyStored() {\n        return energyStored;\n    }\n    \n    /**\n     * Obtém a capacidade máxima de energia\n     * \n     * @return Capacidade máxima\n     */\n    public int getMaxEnergy() {\n        return MAX_ENERGY;\n    }\n    \n    /**\n     * Obtém o progresso atual do processamento (0-100)\n     * \n     * @return Progresso em porcentagem\n     */\n    public int getProcessProgress() {\n        if (!isProcessing) return 0;\n        return (processProgress * 100) / PROCESSING_TIME;\n    }\n    \n    /**\n     * Verifica se a máquina está processando\n     * \n     * @return true se está processando\n     */\n    public boolean isProcessing() {\n        return isProcessing;\n    }\n    \n    /**\n     * Sincroniza dados com o cliente para atualização de GUI\n     */\n    private void syncToClient() {\n        if (level != null && !level.isClientSide()) {\n            // TODO: Implementar sincronização quando necessário\n            // level.sendBlockUpdated(getBlockPos(), getBlockState(), getBlockState(), 3);\n        }\n    }\n    \n    // ================================\n    // PERSISTÊNCIA DE DADOS (NBT)\n    // ================================\n    \n    /**\n     * Salva os dados da BlockEntity para NBT\n     * \n     * @param tag Tag para salvar os dados\n     * @param registries Lookup para registros\n     */\n    @Override\n    protected void saveAdditional(CompoundTag tag, HolderLookup.Provider registries) {\n        super.saveAdditional(tag, registries);\n        \n        tag.putInt(\"energy\", energyStored);\n        tag.putInt(\"progress\", processProgress);\n        tag.putBoolean(\"processing\", isProcessing);\n        \n        // TODO: Salvar inventário quando implementado\n        // tag.put(\"inventory\", inventory.serializeNBT(registries));\n    }\n    \n    /**\n     * Carrega os dados da BlockEntity do NBT\n     * \n     * @param tag Tag com os dados salvos\n     * @param registries Lookup para registros\n     */\n    @Override\n    protected void loadAdditional(CompoundTag tag, HolderLookup.Provider registries) {\n        super.loadAdditional(tag, registries);\n        \n        energyStored = tag.getInt(\"energy\");\n        processProgress = tag.getInt(\"progress\");\n        isProcessing = tag.getBoolean(\"processing\");\n        \n        // TODO: Carregar inventário quando implementado\n        // if (tag.contains(\"inventory\")) {\n        //     inventory.deserializeNBT(registries, tag.getCompound(\"inventory\"));\n        // }\n    }\n}","size_bytes":9302},"src/main/java/com/cronicasaetherium/mod/common/capability/ModCapabilities.java":{"content":"package com.cronicasaetherium.mod.common.capability;\n\nimport com.cronicasaetherium.mod.CronicasAetherium;\nimport net.minecraft.core.Direction;\nimport net.minecraft.resources.ResourceLocation;\nimport net.minecraft.world.entity.Entity;\nimport net.minecraft.world.entity.player.Player;\nimport net.neoforged.bus.api.SubscribeEvent;\nimport net.neoforged.fml.common.EventBusSubscriber;\nimport net.neoforged.neoforge.capabilities.Capabilities;\nimport net.neoforged.neoforge.capabilities.EntityCapability;\nimport net.neoforged.neoforge.capabilities.RegisterCapabilitiesEvent;\nimport net.neoforged.neoforge.event.entity.player.PlayerEvent;\nimport net.neoforged.neoforge.event.entity.EntityJoinLevelEvent;\nimport org.jetbrains.annotations.Nullable;\n\n/**\n * Registro central e gerenciamento das capacidades personalizadas do mod\n * \n * Esta classe é responsável por:\n * - Registrar as capacidades customizadas (PlayerProficiency)\n * - Gerenciar a anexação das capacidades às entidades apropriadas\n * - Lidar com eventos de persistência (morte, clone, etc.)\n * - Fornecer métodos de acesso convenientes para outras classes\n * \n * O sistema de capacidades do NeoForge permite anexar dados customizados\n * a entidades, itens, blocos, etc. de forma que sejam automaticamente\n * sincronizados e persistidos.\n */\n@EventBusSubscriber(modid = CronicasAetherium.MODID, bus = EventBusSubscriber.Bus.MOD)\npublic class ModCapabilities {\n    \n    /**\n     * Capacidade de proficiência do jogador\n     * \n     * Esta capacidade é anexada apenas a jogadores (Player entities)\n     * e armazena informações sobre suas proficiências em engenharia e arcana.\n     * \n     * ResourceLocation: cronicasaetherium:player_proficiency\n     */\n    public static final EntityCapability<PlayerProficiency, Void> PLAYER_PROFICIENCY = \n        EntityCapability.createVoid(\n            ResourceLocation.fromNamespaceAndPath(CronicasAetherium.MODID, \"player_proficiency\"),\n            PlayerProficiency.class\n        );\n    \n    /**\n     * Evento de registro de capacidades\n     * \n     * Este método é chamado durante a fase de registro do mod e é responsável\n     * por registrar todas as capacidades customizadas e definir como elas\n     * são anexadas às entidades apropriadas.\n     * \n     * @param event Evento de registro de capacidades\n     */\n    @SubscribeEvent\n    public static void registerCapabilities(RegisterCapabilitiesEvent event) {\n        // Registra a capacidade de proficiência para jogadores\n        event.registerEntity(\n            PLAYER_PROFICIENCY,\n            Player.class,\n            (player, context) -> new PlayerProficiency()\n        );\n        \n        CronicasAetherium.LOGGER.info(\"Capacidades do mod registradas com sucesso\");\n    }\n    \n    /**\n     * Método utilitário para obter a capacidade de proficiência de um jogador\n     * \n     * Este método fornece uma forma conveniente e segura de acessar a\n     * capacidade de proficiência de um jogador, com verificação de nulidade.\n     * \n     * @param player Jogador do qual obter a capacidade\n     * @return Capacidade de proficiência ou null se não estiver disponível\n     */\n    @Nullable\n    public static PlayerProficiency getPlayerProficiency(Player player) {\n        return player.getCapability(PLAYER_PROFICIENCY);\n    }\n    \n    /**\n     * Método utilitário para verificar se um jogador tem a capacidade de proficiência\n     * \n     * @param player Jogador a verificar\n     * @return true se a capacidade estiver disponível, false caso contrário\n     */\n    public static boolean hasPlayerProficiency(Player player) {\n        return getPlayerProficiency(player) != null;\n    }\n    \n    /**\n     * Método utilitário para executar uma ação na capacidade de proficiência se disponível\n     * \n     * Este método permite executar código que modifica a proficiência do jogador\n     * de forma segura, verificando automaticamente se a capacidade está disponível.\n     * \n     * @param player Jogador alvo\n     * @param action Ação a ser executada na capacidade\n     */\n    public static void ifPlayerProficiencyPresent(Player player, java.util.function.Consumer<PlayerProficiency> action) {\n        PlayerProficiency proficiency = getPlayerProficiency(player);\n        if (proficiency != null) {\n            action.accept(proficiency);\n        }\n    }\n}\n\n/**\n * Event handler para gerenciar eventos relacionados às capacidades\n * \n * Esta classe cuida dos eventos que podem afetar as capacidades dos jogadores,\n * garantindo que os dados sejam preservados corretamente em situações como\n * morte, respawn, viagem dimensional, etc.\n */\n@EventBusSubscriber(modid = CronicasAetherium.MODID, bus = EventBusSubscriber.Bus.GAME)\nclass CapabilityEventHandler {\n    \n    /**\n     * Evento de clone do jogador (ao morrer/respawnar)\n     * \n     * Este evento é chamado quando um jogador morre e respawna, ou quando\n     * viaja entre dimensões. Precisamos copiar os dados de proficiência\n     * da entidade antiga para a nova.\n     * \n     * @param event Evento de clone do jogador\n     */\n    @SubscribeEvent\n    public static void onPlayerClone(PlayerEvent.Clone event) {\n        // Só processa se o jogador estiver vivo (não em estado fantasma)\n        if (event.isWasDeath()) {\n            Player oldPlayer = event.getOriginal();\n            Player newPlayer = event.getEntity();\n            \n            PlayerProficiency oldProficiency = ModCapabilities.getPlayerProficiency(oldPlayer);\n            PlayerProficiency newProficiency = ModCapabilities.getPlayerProficiency(newPlayer);\n            \n            // Copia os dados se ambas as capacidades existirem\n            if (oldProficiency != null && newProficiency != null) {\n                newProficiency.setEngineeringXp(oldProficiency.getEngineeringXp());\n                newProficiency.setArcanaXp(oldProficiency.getArcanaXp());\n                \n                CronicasAetherium.LOGGER.debug(\"Dados de proficiência copiados para o jogador {}: {}\", \n                    newPlayer.getName().getString(), newProficiency.toString());\n            }\n        }\n    }\n    \n    /**\n     * Evento de entrada do jogador no mundo\n     * \n     * Este evento é útil para logging e verificação de que as capacidades\n     * foram anexadas corretamente quando o jogador entra no mundo.\n     * \n     * @param event Evento de entrada da entidade no mundo\n     */\n    @SubscribeEvent\n    public static void onPlayerJoinWorld(EntityJoinLevelEvent event) {\n        Entity entity = event.getEntity();\n        \n        // Verifica apenas jogadores\n        if (entity instanceof Player player && !event.getLevel().isClientSide()) {\n            PlayerProficiency proficiency = ModCapabilities.getPlayerProficiency(player);\n            \n            if (proficiency != null) {\n                CronicasAetherium.LOGGER.debug(\"Jogador {} entrou no mundo com proficiências: {}\", \n                    player.getName().getString(), proficiency.toString());\n            } else {\n                CronicasAetherium.LOGGER.warn(\"Jogador {} entrou no mundo sem capacidade de proficiência!\", \n                    player.getName().getString());\n            }\n        }\n    }\n}","size_bytes":7203},"src/main/java/com/cronicasaetherium/mod/common/capability/PlayerProficiency.java":{"content":"package com.cronicasaetherium.mod.common.capability;\n\nimport net.minecraft.core.HolderLookup;\nimport net.minecraft.nbt.CompoundTag;\nimport net.neoforged.neoforge.common.util.INBTSerializable;\n\n/**\n * Capacidade do jogador para armazenar dados de proficiência\n * \n * Esta classe gerencia os pontos de experiência de diferentes proficiências\n * que o jogador pode desenvolver ao longo do mod. Cada proficiência representa\n * um aspecto diferente do conhecimento: engenharia (tecnologia) e arcana (magia).\n * \n * Os dados persistem através de morte, viagens dimensionais e logout/login.\n * \n * Proficiências disponíveis:\n * - Engenharia: Experiência com máquinas, automação e tecnologia\n * - Arcana: Experiência com magia, rituais e conhecimento místico\n */\npublic class PlayerProficiency implements INBTSerializable<CompoundTag> {\n    \n    // Constantes para as chaves de NBT\n    private static final String ENGINEERING_XP_KEY = \"engineering_xp\";\n    private static final String ARCANA_XP_KEY = \"arcana_xp\";\n    \n    // Constantes para valores mínimos e máximos\n    private static final int MIN_XP = 0;\n    private static final int MAX_XP = Integer.MAX_VALUE;\n    \n    // Armazenamento dos pontos de experiência\n    private int engineeringXp;\n    private int arcanaXp;\n    \n    /**\n     * Construtor padrão\n     * Inicializa ambas as proficiências com 0 pontos de experiência\n     */\n    public PlayerProficiency() {\n        this.engineeringXp = 0;\n        this.arcanaXp = 0;\n    }\n    \n    // ================================\n    // MÉTODOS DE ACESSO À ENGENHARIA\n    // ================================\n    \n    /**\n     * Obtém os pontos de experiência de engenharia do jogador\n     * \n     * @return Quantidade atual de XP de engenharia\n     */\n    public int getEngineeringXp() {\n        return this.engineeringXp;\n    }\n    \n    /**\n     * Define os pontos de experiência de engenharia do jogador\n     * \n     * @param xp Nova quantidade de XP (será limitada entre MIN_XP e MAX_XP)\n     */\n    public void setEngineeringXp(int xp) {\n        this.engineeringXp = Math.max(MIN_XP, Math.min(MAX_XP, xp));\n    }\n    \n    /**\n     * Adiciona pontos de experiência de engenharia\n     * \n     * @param amount Quantidade de XP a ser adicionada (pode ser negativa para remover)\n     * @return Quantidade final de XP de engenharia após a adição\n     */\n    public int addEngineeringXp(int amount) {\n        this.setEngineeringXp(this.engineeringXp + amount);\n        return this.engineeringXp;\n    }\n    \n    // ================================\n    // MÉTODOS DE ACESSO À ARCANA\n    // ================================\n    \n    /**\n     * Obtém os pontos de experiência arcana do jogador\n     * \n     * @return Quantidade atual de XP arcana\n     */\n    public int getArcanaXp() {\n        return this.arcanaXp;\n    }\n    \n    /**\n     * Define os pontos de experiência arcana do jogador\n     * \n     * @param xp Nova quantidade de XP (será limitada entre MIN_XP e MAX_XP)\n     */\n    public void setArcanaXp(int xp) {\n        this.arcanaXp = Math.max(MIN_XP, Math.min(MAX_XP, xp));\n    }\n    \n    /**\n     * Adiciona pontos de experiência arcana\n     * \n     * @param amount Quantidade de XP a ser adicionada (pode ser negativa para remover)\n     * @return Quantidade final de XP arcana após a adição\n     */\n    public int addArcanaXp(int amount) {\n        this.setArcanaXp(this.arcanaXp + amount);\n        return this.arcanaXp;\n    }\n    \n    // ================================\n    // MÉTODOS UTILITÁRIOS\n    // ================================\n    \n    /**\n     * Obtém XP por nome do tipo de proficiência\n     * \n     * @param proficiencyType Tipo de proficiência (\"engenharia\" ou \"arcana\")\n     * @return Quantidade de XP da proficiência especificada, ou 0 se o tipo for inválido\n     */\n    public int getXpByType(String proficiencyType) {\n        return switch (proficiencyType.toLowerCase()) {\n            case \"engenharia\", \"engineering\" -> this.engineeringXp;\n            case \"arcana\", \"arcane\" -> this.arcanaXp;\n            default -> 0;\n        };\n    }\n    \n    /**\n     * Adiciona XP por nome do tipo de proficiência\n     * \n     * @param proficiencyType Tipo de proficiência (\"engenharia\" ou \"arcana\")\n     * @param amount Quantidade de XP a ser adicionada\n     * @return true se a operação foi bem-sucedida, false se o tipo for inválido\n     */\n    public boolean addXpByType(String proficiencyType, int amount) {\n        return switch (proficiencyType.toLowerCase()) {\n            case \"engenharia\", \"engineering\" -> {\n                this.addEngineeringXp(amount);\n                yield true;\n            }\n            case \"arcana\", \"arcane\" -> {\n                this.addArcanaXp(amount);\n                yield true;\n            }\n            default -> false;\n        };\n    }\n    \n    /**\n     * Calcula o nível aproximado com base no XP\n     * Fórmula: sqrt(xp / 100) para crescimento não-linear\n     * \n     * @param xp Pontos de experiência\n     * @return Nível calculado (mínimo 1)\n     */\n    public int calculateLevel(int xp) {\n        return Math.max(1, (int) Math.sqrt(xp / 100.0));\n    }\n    \n    /**\n     * Obtém o nível de engenharia do jogador\n     * \n     * @return Nível atual de engenharia\n     */\n    public int getEngineeringLevel() {\n        return calculateLevel(this.engineeringXp);\n    }\n    \n    /**\n     * Obtém o nível arcana do jogador\n     * \n     * @return Nível atual arcana\n     */\n    public int getArcanaLevel() {\n        return calculateLevel(this.arcanaXp);\n    }\n    \n    /**\n     * Reseta todas as proficiências para 0\n     * Usado principalmente para testes ou eventos especiais\n     */\n    public void resetAll() {\n        this.engineeringXp = 0;\n        this.arcanaXp = 0;\n    }\n    \n    // ================================\n    // SERIALIZAÇÃO NBT\n    // ================================\n    \n    /**\n     * Serializa os dados da proficiência para NBT\n     * Permite que os dados persistam entre sessões e viagens dimensionais\n     * \n     * @param provider Provider para registros de holder\n     * @return CompoundTag contendo todos os dados serializados\n     */\n    @Override\n    public CompoundTag serializeNBT(HolderLookup.Provider provider) {\n        CompoundTag tag = new CompoundTag();\n        tag.putInt(ENGINEERING_XP_KEY, this.engineeringXp);\n        tag.putInt(ARCANA_XP_KEY, this.arcanaXp);\n        return tag;\n    }\n    \n    /**\n     * Deserializa os dados da proficiência do NBT\n     * Carrega os dados salvos quando o jogador entra no mundo\n     * \n     * @param provider Provider para registros de holder\n     * @param nbt CompoundTag contendo os dados salvos\n     */\n    @Override\n    public void deserializeNBT(HolderLookup.Provider provider, CompoundTag nbt) {\n        this.engineeringXp = nbt.getInt(ENGINEERING_XP_KEY);\n        this.arcanaXp = nbt.getInt(ARCANA_XP_KEY);\n    }\n    \n    /**\n     * Método toString para depuração\n     * \n     * @return Representação em string dos dados de proficiência\n     */\n    @Override\n    public String toString() {\n        return String.format(\"PlayerProficiency{engineering=%d (lvl %d), arcana=%d (lvl %d)}\", \n            this.engineeringXp, this.getEngineeringLevel(),\n            this.arcanaXp, this.getArcanaLevel());\n    }\n}","size_bytes":7318},"src/main/java/com/cronicasaetherium/mod/common/commands/ProficiencyCommand.java":{"content":"package com.cronicasaetherium.mod.common.commands;\n\nimport com.cronicasaetherium.mod.common.capability.ModCapabilities;\nimport com.cronicasaetherium.mod.common.capability.PlayerProficiency;\nimport com.mojang.brigadier.CommandDispatcher;\nimport com.mojang.brigadier.arguments.IntegerArgumentType;\nimport com.mojang.brigadier.arguments.StringArgumentType;\nimport com.mojang.brigadier.context.CommandContext;\nimport com.mojang.brigadier.exceptions.CommandSyntaxException;\nimport net.minecraft.commands.CommandSourceStack;\nimport net.minecraft.commands.Commands;\nimport net.minecraft.commands.arguments.EntityArgument;\nimport net.minecraft.network.chat.Component;\nimport net.minecraft.server.level.ServerPlayer;\n\nimport java.util.Collection;\n\n/**\n * Comandos de administrador para o sistema de proficiência\n * \n * Esta classe implementa comandos de console para testar e administrar\n * o sistema de proficiência dos jogadores. Os comandos permitem visualizar\n * e modificar os pontos de experiência de engenharia e arcana.\n * \n * Comandos disponíveis:\n * - /proficiency get <jogador> <tipo> - Visualiza XP atual\n * - /proficiency add <jogador> <tipo> <quantidade> - Adiciona/remove XP\n * - /proficiency set <jogador> <tipo> <quantidade> - Define XP específico\n * - /proficiency reset <jogador> [tipo] - Reseta proficiências\n * \n * Tipos válidos: engenharia, arcana\n */\npublic class ProficiencyCommand {\n    \n    // Constantes para tipos de proficiência válidos\n    private static final String ENGINEERING_TYPE = \"engenharia\";\n    private static final String ARCANA_TYPE = \"arcana\";\n    \n    /**\n     * Registra todos os comandos de proficiência\n     * \n     * Este método deve ser chamado durante o evento de registro de comandos\n     * para disponibilizar os comandos no servidor.\n     * \n     * @param dispatcher Dispatcher de comandos do servidor\n     */\n    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {\n        dispatcher.register(\n            Commands.literal(\"proficiency\")\n                .requires(source -> source.hasPermission(2)) // Requer nível de OP 2\n                .then(\n                    Commands.literal(\"get\")\n                        .then(Commands.argument(\"player\", EntityArgument.player())\n                            .then(Commands.argument(\"type\", StringArgumentType.string())\n                                .suggests((context, builder) -> {\n                                    builder.suggest(ENGINEERING_TYPE);\n                                    builder.suggest(ARCANA_TYPE);\n                                    return builder.buildFuture();\n                                })\n                                .executes(ProficiencyCommand::getProficiency)\n                            )\n                        )\n                )\n                .then(\n                    Commands.literal(\"add\")\n                        .then(Commands.argument(\"player\", EntityArgument.player())\n                            .then(Commands.argument(\"type\", StringArgumentType.string())\n                                .suggests((context, builder) -> {\n                                    builder.suggest(ENGINEERING_TYPE);\n                                    builder.suggest(ARCANA_TYPE);\n                                    return builder.buildFuture();\n                                })\n                                .then(Commands.argument(\"amount\", IntegerArgumentType.integer())\n                                    .executes(ProficiencyCommand::addProficiency)\n                                )\n                            )\n                        )\n                )\n                .then(\n                    Commands.literal(\"set\")\n                        .then(Commands.argument(\"player\", EntityArgument.player())\n                            .then(Commands.argument(\"type\", StringArgumentType.string())\n                                .suggests((context, builder) -> {\n                                    builder.suggest(ENGINEERING_TYPE);\n                                    builder.suggest(ARCANA_TYPE);\n                                    return builder.buildFuture();\n                                })\n                                .then(Commands.argument(\"amount\", IntegerArgumentType.integer(0))\n                                    .executes(ProficiencyCommand::setProficiency)\n                                )\n                            )\n                        )\n                )\n                .then(\n                    Commands.literal(\"reset\")\n                        .then(Commands.argument(\"player\", EntityArgument.player())\n                            .executes(ProficiencyCommand::resetAllProficiency)\n                            .then(Commands.argument(\"type\", StringArgumentType.string())\n                                .suggests((context, builder) -> {\n                                    builder.suggest(ENGINEERING_TYPE);\n                                    builder.suggest(ARCANA_TYPE);\n                                    return builder.buildFuture();\n                                })\n                                .executes(ProficiencyCommand::resetSpecificProficiency)\n                            )\n                        )\n                )\n                .then(\n                    Commands.literal(\"list\")\n                        .then(Commands.argument(\"player\", EntityArgument.player())\n                            .executes(ProficiencyCommand::listAllProficiencies)\n                        )\n                )\n        );\n    }\n    \n    /**\n     * Comando: /proficiency get <jogador> <tipo>\n     * Exibe a quantidade atual de XP de uma proficiência específica\n     * \n     * @param context Contexto do comando\n     * @return Código de retorno do comando (1 = sucesso, 0 = falha)\n     */\n    private static int getProficiency(CommandContext<CommandSourceStack> context) throws CommandSyntaxException {\n        ServerPlayer player = EntityArgument.getPlayer(context, \"player\");\n        String type = StringArgumentType.getString(context, \"type\").toLowerCase();\n        \n        if (!isValidProficiencyType(type)) {\n            context.getSource().sendFailure(Component.literal(\"Tipo de proficiência inválido! Use: \" + ENGINEERING_TYPE + \" ou \" + ARCANA_TYPE));\n            return 0;\n        }\n        \n        PlayerProficiency proficiency = ModCapabilities.getPlayerProficiency(player);\n        if (proficiency == null) {\n            context.getSource().sendFailure(Component.literal(\"Não foi possível acessar as proficiências do jogador \" + player.getName().getString()));\n            return 0;\n        }\n        \n        int xp = proficiency.getXpByType(type);\n        int level = proficiency.calculateLevel(xp);\n        \n        context.getSource().sendSuccess(() -> Component.literal(\n            String.format(\"§6%s§r tem §b%d XP§r de §e%s§r (Nível §a%d§r)\", \n                player.getName().getString(), xp, type, level)\n        ), true);\n        \n        return 1;\n    }\n    \n    /**\n     * Comando: /proficiency add <jogador> <tipo> <quantidade>\n     * Adiciona (ou remove se negativo) XP de uma proficiência\n     * \n     * @param context Contexto do comando\n     * @return Código de retorno do comando\n     */\n    private static int addProficiency(CommandContext<CommandSourceStack> context) throws CommandSyntaxException {\n        ServerPlayer player = EntityArgument.getPlayer(context, \"player\");\n        String type = StringArgumentType.getString(context, \"type\").toLowerCase();\n        int amount = IntegerArgumentType.getInteger(context, \"amount\");\n        \n        if (!isValidProficiencyType(type)) {\n            context.getSource().sendFailure(Component.literal(\"Tipo de proficiência inválido! Use: \" + ENGINEERING_TYPE + \" ou \" + ARCANA_TYPE));\n            return 0;\n        }\n        \n        PlayerProficiency proficiency = ModCapabilities.getPlayerProficiency(player);\n        if (proficiency == null) {\n            context.getSource().sendFailure(Component.literal(\"Não foi possível acessar as proficiências do jogador \" + player.getName().getString()));\n            return 0;\n        }\n        \n        int oldXp = proficiency.getXpByType(type);\n        boolean success = proficiency.addXpByType(type, amount);\n        \n        if (!success) {\n            context.getSource().sendFailure(Component.literal(\"Erro ao modificar proficiência\"));\n            return 0;\n        }\n        \n        int newXp = proficiency.getXpByType(type);\n        int newLevel = proficiency.calculateLevel(newXp);\n        \n        String action = amount >= 0 ? \"adicionado\" : \"removido\";\n        context.getSource().sendSuccess(() -> Component.literal(\n            String.format(\"§6%s XP§r %s para §e%s§r de §6%s§r. Total: §b%d XP§r (Nível §a%d§r)\", \n                Math.abs(amount), action, type, player.getName().getString(), newXp, newLevel)\n        ), true);\n        \n        return 1;\n    }\n    \n    /**\n     * Comando: /proficiency set <jogador> <tipo> <quantidade>\n     * Define a quantidade exata de XP de uma proficiência\n     * \n     * @param context Contexto do comando\n     * @return Código de retorno do comando\n     */\n    private static int setProficiency(CommandContext<CommandSourceStack> context) throws CommandSyntaxException {\n        ServerPlayer player = EntityArgument.getPlayer(context, \"player\");\n        String type = StringArgumentType.getString(context, \"type\").toLowerCase();\n        int amount = IntegerArgumentType.getInteger(context, \"amount\");\n        \n        if (!isValidProficiencyType(type)) {\n            context.getSource().sendFailure(Component.literal(\"Tipo de proficiência inválido! Use: \" + ENGINEERING_TYPE + \" ou \" + ARCANA_TYPE));\n            return 0;\n        }\n        \n        PlayerProficiency proficiency = ModCapabilities.getPlayerProficiency(player);\n        if (proficiency == null) {\n            context.getSource().sendFailure(Component.literal(\"Não foi possível acessar as proficiências do jogador \" + player.getName().getString()));\n            return 0;\n        }\n        \n        if (type.equals(ENGINEERING_TYPE)) {\n            proficiency.setEngineeringXp(amount);\n        } else {\n            proficiency.setArcanaXp(amount);\n        }\n        \n        int level = proficiency.calculateLevel(amount);\n        \n        context.getSource().sendSuccess(() -> Component.literal(\n            String.format(\"Proficiência §e%s§r de §6%s§r definida para §b%d XP§r (Nível §a%d§r)\", \n                type, player.getName().getString(), amount, level)\n        ), true);\n        \n        return 1;\n    }\n    \n    /**\n     * Comando: /proficiency reset <jogador>\n     * Reseta todas as proficiências do jogador para 0\n     * \n     * @param context Contexto do comando\n     * @return Código de retorno do comando\n     */\n    private static int resetAllProficiency(CommandContext<CommandSourceStack> context) throws CommandSyntaxException {\n        ServerPlayer player = EntityArgument.getPlayer(context, \"player\");\n        \n        PlayerProficiency proficiency = ModCapabilities.getPlayerProficiency(player);\n        if (proficiency == null) {\n            context.getSource().sendFailure(Component.literal(\"Não foi possível acessar as proficiências do jogador \" + player.getName().getString()));\n            return 0;\n        }\n        \n        proficiency.resetAll();\n        \n        context.getSource().sendSuccess(() -> Component.literal(\n            String.format(\"Todas as proficiências de §6%s§r foram resetadas\", player.getName().getString())\n        ), true);\n        \n        return 1;\n    }\n    \n    /**\n     * Comando: /proficiency reset <jogador> <tipo>\n     * Reseta uma proficiência específica do jogador para 0\n     * \n     * @param context Contexto do comando\n     * @return Código de retorno do comando\n     */\n    private static int resetSpecificProficiency(CommandContext<CommandSourceStack> context) throws CommandSyntaxException {\n        ServerPlayer player = EntityArgument.getPlayer(context, \"player\");\n        String type = StringArgumentType.getString(context, \"type\").toLowerCase();\n        \n        if (!isValidProficiencyType(type)) {\n            context.getSource().sendFailure(Component.literal(\"Tipo de proficiência inválido! Use: \" + ENGINEERING_TYPE + \" ou \" + ARCANA_TYPE));\n            return 0;\n        }\n        \n        PlayerProficiency proficiency = ModCapabilities.getPlayerProficiency(player);\n        if (proficiency == null) {\n            context.getSource().sendFailure(Component.literal(\"Não foi possível acessar as proficiências do jogador \" + player.getName().getString()));\n            return 0;\n        }\n        \n        if (type.equals(ENGINEERING_TYPE)) {\n            proficiency.setEngineeringXp(0);\n        } else {\n            proficiency.setArcanaXp(0);\n        }\n        \n        context.getSource().sendSuccess(() -> Component.literal(\n            String.format(\"Proficiência §e%s§r de §6%s§r foi resetada\", type, player.getName().getString())\n        ), true);\n        \n        return 1;\n    }\n    \n    /**\n     * Comando: /proficiency list <jogador>\n     * Lista todas as proficiências do jogador\n     * \n     * @param context Contexto do comando\n     * @return Código de retorno do comando\n     */\n    private static int listAllProficiencies(CommandContext<CommandSourceStack> context) throws CommandSyntaxException {\n        ServerPlayer player = EntityArgument.getPlayer(context, \"player\");\n        \n        PlayerProficiency proficiency = ModCapabilities.getPlayerProficiency(player);\n        if (proficiency == null) {\n            context.getSource().sendFailure(Component.literal(\"Não foi possível acessar as proficiências do jogador \" + player.getName().getString()));\n            return 0;\n        }\n        \n        int engXp = proficiency.getEngineeringXp();\n        int engLevel = proficiency.getEngineeringLevel();\n        int arcXp = proficiency.getArcanaXp();\n        int arcLevel = proficiency.getArcanaLevel();\n        \n        context.getSource().sendSuccess(() -> Component.literal(\n            String.format(\"§6=== Proficiências de %s ===\", player.getName().getString())\n        ), false);\n        \n        context.getSource().sendSuccess(() -> Component.literal(\n            String.format(\"§e⚙ Engenharia:§r §b%d XP§r (Nível §a%d§r)\", engXp, engLevel)\n        ), false);\n        \n        context.getSource().sendSuccess(() -> Component.literal(\n            String.format(\"§e✨ Arcana:§r §b%d XP§r (Nível §a%d§r)\", arcXp, arcLevel)\n        ), false);\n        \n        return 1;\n    }\n    \n    /**\n     * Verifica se um tipo de proficiência é válido\n     * \n     * @param type Tipo a verificar\n     * @return true se for válido, false caso contrário\n     */\n    private static boolean isValidProficiencyType(String type) {\n        return ENGINEERING_TYPE.equals(type) || ARCANA_TYPE.equals(type);\n    }\n}","size_bytes":14954},"src/main/java/com/cronicasaetherium/mod/items/dimension/UnstableHeartItem.java":{"content":"package com.cronicasaetherium.mod.items.dimension;\n\nimport com.cronicasaetherium.mod.registry.ModBlocks;\nimport net.minecraft.core.BlockPos;\nimport net.minecraft.sounds.SoundEvents;\nimport net.minecraft.sounds.SoundSource;\nimport net.minecraft.world.InteractionResult;\nimport net.minecraft.world.entity.player.Player;\nimport net.minecraft.world.item.Item;\nimport net.minecraft.world.item.ItemStack;\nimport net.minecraft.world.item.context.UseOnContext;\nimport net.minecraft.world.level.Level;\nimport net.minecraft.world.level.block.state.BlockState;\n\n/**\n * Coração Instável - Ativador do Portal Arcano\n * \n * Este item é usado para ativar estruturas de portal construídas com\n * blocos de Estrutura do Portal Arcano. Quando usado na estrutura correta,\n * cria um portal funcional para a dimensão Crisol Arcano.\n * \n * Funcionalidades:\n * - Ativação de portais em estruturas válidas\n * - Validação da forma do portal (3x3 básico)\n * - Consumo do item ao ativar o portal\n * - Efeitos visuais e sonoros de ativação\n * - Integração com sistema de proficiência arcana\n */\npublic class UnstableHeartItem extends Item {\n    \n    /**\n     * Construtor do Coração Instável\n     * \n     * @param properties Propriedades do item\n     */\n    public UnstableHeartItem(Properties properties) {\n        super(properties);\n    }\n    \n    /**\n     * Manipula o uso do item em blocos\n     * \n     * Verifica se o bloco alvo faz parte de uma estrutura de portal válida\n     * e ativa o portal se a estrutura estiver correta.\n     * \n     * @param context Contexto do uso\n     * @return Resultado da interação\n     */\n    @Override\n    public InteractionResult useOn(UseOnContext context) {\n        Level level = context.getLevel();\n        BlockPos pos = context.getClickedPos();\n        Player player = context.getPlayer();\n        ItemStack heartStack = context.getItemInHand();\n        \n        if (level.isClientSide() || player == null) {\n            return InteractionResult.SUCCESS;\n        }\n        \n        BlockState clickedBlock = level.getBlockState(pos);\n        \n        // Verifica se foi clicado em um bloco de estrutura de portal\n        if (clickedBlock.is(ModBlocks.ARCANE_PORTAL_FRAME.get())) {\n            return attemptPortalActivation(level, pos, player, heartStack);\n        }\n        \n        // Bloco inválido\n        player.sendSystemMessage(net.minecraft.network.chat.Component.literal(\n            \"§cO Coração Instável deve ser usado em uma Estrutura do Portal Arcano.\"));\n        \n        return InteractionResult.FAIL;\n    }\n    \n    /**\n     * Tenta ativar um portal na posição especificada\n     * \n     * @param level Nível/mundo\n     * @param centerPos Posição central do portal\n     * @param player Jogador ativando\n     * @param heartStack Stack do coração instável\n     * @return Resultado da tentativa\n     */\n    private InteractionResult attemptPortalActivation(Level level, BlockPos centerPos, Player player, ItemStack heartStack) {\n        // Verifica se há uma estrutura de portal válida ao redor\n        if (!isValidPortalStructure(level, centerPos)) {\n            player.sendSystemMessage(net.minecraft.network.chat.Component.literal(\n                \"§cEstrutura de portal inválida! Construa um quadrado 3x3 de Estruturas do Portal Arcano.\"));\n            return InteractionResult.FAIL;\n        }\n        \n        // Encontra o centro da estrutura 3x3\n        BlockPos portalCenter = findPortalCenter(level, centerPos);\n        if (portalCenter == null) {\n            player.sendSystemMessage(net.minecraft.network.chat.Component.literal(\n                \"§cNão foi possível determinar o centro do portal.\"));\n            return InteractionResult.FAIL;\n        }\n        \n        // Ativa o portal\n        activatePortal(level, portalCenter, player);\n        \n        // Consome o coração instável\n        heartStack.shrink(1);\n        \n        player.sendSystemMessage(net.minecraft.network.chat.Component.literal(\n            \"§5✨ Portal Arcano ativado! O caminho para o Crisol Arcano está aberto.\"));\n        \n        return InteractionResult.SUCCESS;\n    }\n    \n    /**\n     * Verifica se há uma estrutura de portal válida ao redor da posição\n     * \n     * @param level Nível/mundo\n     * @param pos Posição a verificar\n     * @return true se a estrutura é válida\n     */\n    private boolean isValidPortalStructure(Level level, BlockPos pos) {\n        // Verifica um padrão 3x3 de blocos de estrutura de portal\n        // com o centro vazio (onde será colocado o portal ativo)\n        \n        int frameCount = 0;\n        BlockPos centerCandidate = null;\n        \n        // Procura por uma estrutura 3x3 válida na área\n        for (int dx = -1; dx <= 1; dx++) {\n            for (int dz = -1; dz <= 1; dz++) {\n                BlockPos checkPos = pos.offset(dx, 0, dz);\n                BlockState state = level.getBlockState(checkPos);\n                \n                if (dx == 0 && dz == 0) {\n                    // Centro - deve estar vazio\n                    if (state.isAir()) {\n                        centerCandidate = checkPos;\n                    }\n                } else {\n                    // Bordas - devem ser estruturas de portal\n                    if (state.is(ModBlocks.ARCANE_PORTAL_FRAME.get())) {\n                        frameCount++;\n                    }\n                }\n            }\n        }\n        \n        // Estrutura válida: 8 blocos de frame e centro vazio\n        return frameCount >= 8 && centerCandidate != null;\n    }\n    \n    /**\n     * Encontra o centro de uma estrutura de portal válida\n     * \n     * @param level Nível/mundo\n     * @param startPos Posição inicial de busca\n     * @return Posição do centro ou null se não encontrar\n     */\n    private BlockPos findPortalCenter(Level level, BlockPos startPos) {\n        // Verifica as posições adjacentes para encontrar o centro vazio\n        for (int dx = -1; dx <= 1; dx++) {\n            for (int dz = -1; dz <= 1; dz++) {\n                BlockPos testCenter = startPos.offset(dx, 0, dz);\n                if (level.getBlockState(testCenter).isAir()) {\n                    // Verifica se esta posição realmente está no centro de uma estrutura válida\n                    if (isValidPortalStructure(level, testCenter)) {\n                        return testCenter;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    \n    /**\n     * Ativa o portal na posição especificada\n     * \n     * @param level Nível/mundo\n     * @param centerPos Posição central do portal\n     * @param player Jogador que ativou\n     */\n    private void activatePortal(Level level, BlockPos centerPos, Player player) {\n        // Coloca o bloco de portal ativo no centro\n        level.setBlock(centerPos, ModBlocks.ARCANE_PORTAL.get().defaultBlockState(), 3);\n        \n        // Efeitos visuais e sonoros\n        level.playSound(null, centerPos, SoundEvents.END_PORTAL_TRIGGER, \n            SoundSource.BLOCKS, 1.0f, 1.0f);\n        \n        level.playSound(null, centerPos, SoundEvents.ENCHANTMENT_TABLE_USE, \n            SoundSource.BLOCKS, 0.8f, 1.2f);\n        \n        // TODO: Adicionar partículas especiais quando o sistema for expandido\n        // TODO: Adicionar XP de proficiência arcana para o jogador\n        // ModCapabilities.ifPlayerProficiencyPresent(player, proficiency -> {\n        //     proficiency.addArcanaXp(ModConfig.BASE_ARCANA_XP.get() * 2); // Bônus por ativar portal\n        // });\n    }\n}","size_bytes":7543},"src/main/java/com/cronicasaetherium/mod/items/lore/WornJournalItem.java":{"content":"package com.cronicasaetherium.mod.items.lore;\n\nimport net.minecraft.network.chat.Component;\nimport net.minecraft.world.InteractionHand;\nimport net.minecraft.world.InteractionResultHolder;\nimport net.minecraft.world.entity.player.Player;\nimport net.minecraft.world.item.Item;\nimport net.minecraft.world.item.ItemStack;\nimport net.minecraft.world.level.Level;\n\n/**\n * Diário Desgastado - Item de lore introdutório\n * \n * Este item contém fragmentos da história e lore do mod Crônicas de Aetherium.\n * Quando usado, exibe textos introdutórios que explicam o mundo, a história\n * e os sistemas do mod de forma imersiva.\n * \n * Funcionalidades:\n * - Interface de lore com múltiplas páginas\n * - Textos introdutórios sobre o mundo de Aetherium\n * - Orientações básicas sobre os sistemas do mod\n * - Design imersivo que complementa a experiência\n */\npublic class WornJournalItem extends Item {\n    \n    // Páginas do diário com conteúdo de lore\n    private static final String[] LORE_PAGES = {\n        // Página 1 - Introdução\n        \"§6=== Crônicas de Aetherium ===§r\\n\\n\" +\n        \"§7Fragmento 1:§r\\n\\n\" +\n        \"...o mundo rachou, e de suas veias cristalinas, uma nova energia emergiu. \" +\n        \"O Aetherium, como veio a ser chamado, não era apenas um minério comum - \" +\n        \"era a materialização da própria força vital do universo.\\n\\n\" +\n        \"§oAs antigas civilizações descobriram que esta energia podia ser \" +\n        \"moldada tanto pela engenhosidade quanto pela magia...§r\",\n        \n        // Página 2 - Os Dois Caminhos\n        \"§6=== Os Dois Caminhos ===§r\\n\\n\" +\n        \"§7Fragmento 2:§r\\n\\n\" +\n        \"Dois caminhos emergiram entre os estudiosos do Aetherium:\\n\\n\" +\n        \"§e⚙ A Engenharia§r - Aqueles que buscavam dominar a energia através \" +\n        \"de máquinas precisas, engrenagens e automação. Eles viam no Aetherium \" +\n        \"uma fonte de poder tecnológico.\\n\\n\" +\n        \"§d✨ A Arcana§r - Aqueles que compreendiam a natureza mística da energia, \" +\n        \"canalizando-a através de rituais, plantas e conhecimento ancestral.\",\n        \n        // Página 3 - A Sinergia\n        \"§6=== A Grande Descoberta ===§r\\n\\n\" +\n        \"§7Fragmento 3:§r\\n\\n\" +\n        \"§5Mas os mais sábios descobriram que os dois caminhos não eram opostos - \" +\n        \"eram complementares.§r\\n\\n\" +\n        \"Máquinas imbuídas com essência mágica operavam com eficiência impossível. \" +\n        \"Rituais alimentados por energia tecnológica alcançavam poder inimaginável.\\n\\n\" +\n        \"§oA verdadeira maestria do Aetherium vem da harmonia entre \" +\n        \"tecnologia e magia...§r\",\n        \n        // Página 4 - O Crisol Arcano\n        \"§6=== O Crisol Arcano ===§r\\n\\n\" +\n        \"§7Fragmento 4:§r\\n\\n\" +\n        \"Além do véu da realidade existe um lugar onde o Aetherium cresce \" +\n        \"em cristalizações puras - o §bCrisol Arcano§r.\\n\\n\" +\n        \"Esta dimensão instável é tanto um laboratório quanto um campo de provas. \" +\n        \"Apenas aqueles com coragem e conhecimento suficiente podem ativar \" +\n        \"os antigos portais que levam a este reino.\\n\\n\" +\n        \"§cCuidado - o Crisol não perdoa os despreparados...§r\",\n        \n        // Página 5 - Orientações Práticas\n        \"§6=== Primeiros Passos ===§r\\n\\n\" +\n        \"§7Para o Explorador Iniciante:§r\\n\\n\" +\n        \"§e1.§r Mine §bAetherium§r nas profundezas e estruturas antigas\\n\" +\n        \"§e2.§r Escolha seu caminho: §6Engenharia§r ou §dArcana§r\\n\" +\n        \"§e3.§r Construa suas primeiras máquinas ou altares\\n\" +\n        \"§e4.§r Ganhe experiência em sua proficiência escolhida\\n\" +\n        \"§e5.§r Descubra a sinergia entre os sistemas\\n\\n\" +\n        \"§oLembre-se: a jornada mais gratificante combina ambos os caminhos.§r\"\n    };\n    \n    /**\n     * Construtor do Diário Desgastado\n     * \n     * @param properties Propriedades do item\n     */\n    public WornJournalItem(Properties properties) {\n        super(properties);\n    }\n    \n    /**\n     * Manipula o uso do diário\n     * \n     * Quando o jogador usa o item (botão direito), abre a interface\n     * de lore com os textos introdutórios do mod.\n     * \n     * @param level Nível/mundo\n     * @param player Jogador que usou o item\n     * @param usedHand Mão usada\n     * @return Resultado da interação\n     */\n    @Override\n    public InteractionResultHolder<ItemStack> use(Level level, Player player, InteractionHand usedHand) {\n        ItemStack stack = player.getItemInHand(usedHand);\n        \n        if (!level.isClientSide()) {\n            openJournalInterface(player);\n        }\n        \n        return InteractionResultHolder.success(stack);\n    }\n    \n    /**\n     * Abre a interface de lore do diário\n     * \n     * Por ora, exibe as páginas como mensagens no chat.\n     * Em uma implementação futura, seria uma GUI dedicada.\n     * \n     * @param player Jogador que verá o conteúdo\n     */\n    private void openJournalInterface(Player player) {\n        // TODO: Implementar GUI dedicada para o diário\n        // Por ora, exibe o conteúdo no chat\n        \n        player.sendSystemMessage(Component.literal(\"§6📖 Abrindo o Diário Desgastado...§r\"));\n        \n        // Determina qual página mostrar baseado em um estado persistente\n        // Por simplicidade, mostra uma página aleatória ou sequencial\n        int pageIndex = (int) (player.level().getGameTime() / 100) % LORE_PAGES.length;\n        String currentPage = LORE_PAGES[pageIndex];\n        \n        // Divide o conteúdo em linhas para melhor formatação no chat\n        String[] lines = currentPage.split(\"\\n\");\n        \n        // Exibe o cabeçalho\n        player.sendSystemMessage(Component.literal(\"§8\" + \"=\".repeat(40) + \"§r\"));\n        \n        // Exibe o conteúdo da página\n        for (String line : lines) {\n            if (!line.trim().isEmpty()) {\n                player.sendSystemMessage(Component.literal(line));\n            } else {\n                player.sendSystemMessage(Component.literal(\"\")); // Linha vazia\n            }\n        }\n        \n        // Exibe informações de navegação\n        player.sendSystemMessage(Component.literal(\"\"));\n        player.sendSystemMessage(Component.literal(\n            String.format(\"§8Página %d de %d - Use novamente para a próxima página§r\", \n                pageIndex + 1, LORE_PAGES.length)));\n        player.sendSystemMessage(Component.literal(\"§8\" + \"=\".repeat(40) + \"§r\"));\n        \n        // Som de virar página\n        player.level().playSound(null, player.blockPosition(), \n            net.minecraft.sounds.SoundEvents.ITEM_BOOK_PAGE_TURN, \n            net.minecraft.sounds.SoundSource.PLAYERS, 0.7f, 1.0f);\n    }\n}","size_bytes":6775},"src/main/java/com/cronicasaetherium/mod/items/synergy/RuneOfEfficiencyItem.java":{"content":"package com.cronicasaetherium.mod.items.synergy;\n\nimport com.cronicasaetherium.mod.CronicasAetherium;\nimport net.minecraft.core.BlockPos;\nimport net.minecraft.core.particles.ParticleTypes;\nimport net.minecraft.server.level.ServerLevel;\nimport net.minecraft.sounds.SoundEvents;\nimport net.minecraft.sounds.SoundSource;\nimport net.minecraft.world.InteractionResult;\nimport net.minecraft.world.entity.player.Player;\nimport net.minecraft.world.item.Item;\nimport net.minecraft.world.item.ItemStack;\nimport net.minecraft.world.item.context.UseOnContext;\nimport net.minecraft.world.level.Level;\nimport net.minecraft.world.level.block.entity.BlockEntity;\nimport net.minecraft.world.level.block.state.BlockState;\n\n/**\n * Runa de Eficiência - Item de sinergia Magia → Tecnologia\n * \n * Esta runa representa a aplicação de conhecimento mágico para aprimorar\n * sistemas tecnológicos. Quando aplicada em máquinas, concede bônus de\n * eficiência, velocidade ou capacidade.\n * \n * Funcionalidades:\n * - Aplicação em máquinas para conceder buffs\n * - Efeito visual mágico quando usada\n * - Consumo único (runa é destruída ao usar)\n * - Integração com sistema de proficiência arcana\n * - Diferentes níveis de eficiência baseados no conhecimento do jogador\n * \n * A runa é fundamental para jogadores que focam em magia mas querem\n * otimizar sistemas tecnológicos, promovendo sinergia entre os paths.\n */\npublic class RuneOfEfficiencyItem extends Item {\n    \n    // Constantes de configuração da runa\n    private static final int BASE_EFFICIENCY_BONUS = 25; // Bônus base de eficiência em %\n    private static final int PARTICLE_COUNT = 20; // Número de partículas do efeito visual\n    private static final double PARTICLE_SPREAD = 1.5; // Dispersão das partículas\n    \n    /**\n     * Construtor da Runa de Eficiência\n     * \n     * @param properties Propriedades do item (durabilidade, stack size, etc.)\n     */\n    public RuneOfEfficiencyItem(Properties properties) {\n        super(properties);\n    }\n    \n    /**\n     * Manipula o uso da runa em blocos (máquinas)\n     * \n     * Este método é chamado quando o jogador usa a runa (botão direito)\n     * em um bloco. Verifica se o bloco é uma máquina válida e aplica\n     * o efeito de eficiência se for o caso.\n     * \n     * @param context Contexto do uso (jogador, posição, bloco, etc.)\n     * @return Resultado da interação\n     */\n    @Override\n    public InteractionResult useOn(UseOnContext context) {\n        Level level = context.getLevel();\n        BlockPos pos = context.getClickedPos();\n        Player player = context.getPlayer();\n        ItemStack runeStack = context.getItemInHand();\n        \n        if (level.isClientSide() || player == null) {\n            return InteractionResult.SUCCESS; // Processa apenas no servidor\n        }\n        \n        BlockState blockState = level.getBlockState(pos);\n        BlockEntity blockEntity = level.getBlockEntity(pos);\n        \n        // Verifica se o bloco é uma máquina válida\n        if (isMachineBlock(blockState, blockEntity)) {\n            // Aplica o efeito de eficiência\n            boolean success = applyEfficiencyEffect(level, pos, blockState, blockEntity, player);\n            \n            if (success) {\n                // Consome a runa\n                runeStack.shrink(1);\n                \n                // Efeitos audiovisuais\n                playEffectSounds(level, pos);\n                spawnMagicalParticles((ServerLevel) level, pos);\n                \n                // Mensagem de sucesso para o jogador\n                player.sendSystemMessage(net.minecraft.network.chat.Component.literal(\n                    \"§5✨ Runa de Eficiência aplicada! A máquina agora opera com \" + \n                    BASE_EFFICIENCY_BONUS + \"% mais eficiência.\"));\n                \n                CronicasAetherium.LOGGER.info(\"Jogador {} aplicou Runa de Eficiência na posição {}\", \n                    player.getName().getString(), pos);\n                \n                return InteractionResult.SUCCESS;\n            }\n        }\n        \n        // Falha na aplicação - máquina inválida ou já aprimorada\n        player.sendSystemMessage(net.minecraft.network.chat.Component.literal(\n            \"§cEsta runa não pode ser aplicada aqui. Certifique-se de usar em uma máquina válida.\"));\n        \n        return InteractionResult.FAIL;\n    }\n    \n    /**\n     * Verifica se um bloco é uma máquina válida para aplicar a runa\n     * \n     * @param blockState Estado do bloco\n     * @param blockEntity BlockEntity do bloco (se houver)\n     * @return true se for uma máquina válida\n     */\n    private boolean isMachineBlock(BlockState blockState, BlockEntity blockEntity) {\n        if (blockEntity == null) {\n            return false; // Máquinas sempre têm BlockEntity\n        }\n        \n        // TODO: Expandir com verificações específicas quando mais máquinas forem adicionadas\n        // Por ora, verifica se é uma das máquinas conhecidas do mod\n        String blockName = blockState.getBlock().toString().toLowerCase();\n        \n        return blockName.contains(\"forge\") || \n               blockName.contains(\"mill\") || \n               blockName.contains(\"infuser\") ||\n               blockName.contains(\"altar\");\n    }\n    \n    /**\n     * Aplica o efeito de eficiência na máquina\n     * \n     * @param level Nível/mundo\n     * @param pos Posição da máquina\n     * @param blockState Estado do bloco da máquina\n     * @param blockEntity BlockEntity da máquina\n     * @param player Jogador que aplicou a runa\n     * @return true se o efeito foi aplicado com sucesso\n     */\n    private boolean applyEfficiencyEffect(Level level, BlockPos pos, BlockState blockState, \n                                        BlockEntity blockEntity, Player player) {\n        \n        // TODO: Implementar o sistema real de bônus de eficiência quando as máquinas forem expandidas\n        // Por ora, apenas registra que o efeito foi aplicado\n        \n        // Verifica se a máquina já tem bônus aplicado\n        if (hasEfficiencyBonus(blockEntity)) {\n            player.sendSystemMessage(net.minecraft.network.chat.Component.literal(\n                \"§6Esta máquina já possui um bônus de eficiência ativo.\"));\n            return false;\n        }\n        \n        // Calcula o bônus baseado na proficiência arcana do jogador\n        int effectivenessBonus = calculateBonusFromProficiency(player);\n        \n        // Aplica o bônus na máquina\n        applyBonusToMachine(blockEntity, effectivenessBonus);\n        \n        CronicasAetherium.LOGGER.debug(\"Bônus de eficiência de {}% aplicado na máquina na posição {}\", \n            effectivenessBonus, pos);\n        \n        return true;\n    }\n    \n    /**\n     * Verifica se uma máquina já possui bônus de eficiência\n     * \n     * @param blockEntity BlockEntity da máquina\n     * @return true se já possui bônus\n     */\n    private boolean hasEfficiencyBonus(BlockEntity blockEntity) {\n        // TODO: Implementar verificação real de bônus quando o sistema for expandido\n        // Por ora, assume que não há bônus aplicado\n        return false;\n    }\n    \n    /**\n     * Calcula o bônus de eficiência baseado na proficiência arcana do jogador\n     * \n     * @param player Jogador que aplicou a runa\n     * @return Porcentagem de bônus adicional\n     */\n    private int calculateBonusFromProficiency(Player player) {\n        // TODO: Integrar com o sistema de proficiência quando implementado\n        // Por ora, retorna o bônus base\n        \n        // PlayerProficiency proficiency = ModCapabilities.getPlayerProficiency(player);\n        // if (proficiency != null) {\n        //     int arcanaLevel = proficiency.getArcanaLevel();\n        //     return BASE_EFFICIENCY_BONUS + (arcanaLevel * 5); // +5% por nível\n        // }\n        \n        return BASE_EFFICIENCY_BONUS;\n    }\n    \n    /**\n     * Aplica o bônus de eficiência na BlockEntity da máquina\n     * \n     * @param blockEntity BlockEntity da máquina\n     * @param bonusPercentage Porcentagem de bônus a aplicar\n     */\n    private void applyBonusToMachine(BlockEntity blockEntity, int bonusPercentage) {\n        // TODO: Implementar aplicação real do bônus quando o sistema de máquinas for expandido\n        // Isso pode envolver:\n        // - Marcar a máquina como aprimorada\n        // - Armazenar o valor do bônus em NBT\n        // - Modificar velocidade de processamento\n        // - Reduzir consumo de energia\n        \n        CronicasAetherium.LOGGER.debug(\"Aplicando bônus de {}% na máquina {}\", \n            bonusPercentage, blockEntity.getClass().getSimpleName());\n    }\n    \n    /**\n     * Reproduz sons mágicos quando a runa é aplicada\n     * \n     * @param level Nível/mundo\n     * @param pos Posição onde reproduzir o som\n     */\n    private void playEffectSounds(Level level, BlockPos pos) {\n        // Som de encantamento quando a runa é aplicada\n        level.playSound(null, pos, SoundEvents.ENCHANTMENT_TABLE_USE, \n            SoundSource.BLOCKS, 0.8f, 1.2f);\n        \n        // Som adicional de sino mágico\n        level.playSound(null, pos, SoundEvents.BELL_RESONATE, \n            SoundSource.BLOCKS, 0.5f, 1.5f);\n    }\n    \n    /**\n     * Gera partículas mágicas ao redor da máquina aprimorada\n     * \n     * @param level Nível do servidor\n     * @param pos Posição central das partículas\n     */\n    private void spawnMagicalParticles(ServerLevel level, BlockPos pos) {\n        // Partículas de encantamento ao redor da máquina\n        for (int i = 0; i < PARTICLE_COUNT; i++) {\n            double offsetX = (level.random.nextDouble() - 0.5) * PARTICLE_SPREAD;\n            double offsetY = level.random.nextDouble() * PARTICLE_SPREAD;\n            double offsetZ = (level.random.nextDouble() - 0.5) * PARTICLE_SPREAD;\n            \n            level.sendParticles(ParticleTypes.ENCHANT,\n                pos.getX() + 0.5 + offsetX,\n                pos.getY() + 0.5 + offsetY,\n                pos.getZ() + 0.5 + offsetZ,\n                1, 0, 0.1, 0, 0.02);\n        }\n        \n        // Partículas douradas para indicar aprimoramento\n        for (int i = 0; i < PARTICLE_COUNT / 2; i++) {\n            double offsetX = (level.random.nextDouble() - 0.5) * PARTICLE_SPREAD * 0.7;\n            double offsetY = level.random.nextDouble() * PARTICLE_SPREAD * 0.7;\n            double offsetZ = (level.random.nextDouble() - 0.5) * PARTICLE_SPREAD * 0.7;\n            \n            level.sendParticles(ParticleTypes.HAPPY_VILLAGER,\n                pos.getX() + 0.5 + offsetX,\n                pos.getY() + 0.5 + offsetY,\n                pos.getZ() + 0.5 + offsetZ,\n                1, 0, 0.05, 0, 0.01);\n        }\n    }\n}","size_bytes":10777},"src/main/java/com/cronicasaetherium/mod/world/biome/ModBiomes.java":{"content":"package com.cronicasaetherium.mod.world.biome;\n\nimport com.cronicasaetherium.mod.CronicasAetherium;\nimport net.minecraft.core.registries.Registries;\nimport net.minecraft.data.worldgen.BiomeDefaultFeatures;\nimport net.minecraft.data.worldgen.BootstrapContext;\nimport net.minecraft.resources.ResourceKey;\nimport net.minecraft.resources.ResourceLocation;\nimport net.minecraft.sounds.Musics;\nimport net.minecraft.sounds.SoundEvents;\nimport net.minecraft.world.level.biome.*;\n\n/**\n * Registro e configuração dos biomas customizados do mod\n * \n * Esta classe define os biomas únicos encontrados nas dimensões do mod,\n * incluindo suas características ambientais, efeitos especiais e spawns.\n * \n * Biomas implementados:\n * - Estepes Cristalinas: Bioma principal do Crisol Arcano\n */\npublic class ModBiomes {\n    \n    /**\n     * Estepes Cristalinas - Bioma principal da dimensão Crisol Arcano\n     * \n     * Um bioma desolado coberto por cristais e terra cristalizada.\n     * Características:\n     * - Terreno predominantemente plano com formações cristalinas\n     * - Partículas ambientais de energia mágica\n     * - Minérios de Aetherium abundantes\n     * - Clima frio e seco\n     * - Efeitos de brilho noturno\n     */\n    public static final ResourceKey<Biome> CRYSTALLINE_WASTES = ResourceKey.create(Registries.BIOME,\n        ResourceLocation.fromNamespaceAndPath(CronicasAetherium.MODID, \"crystalline_wastes\"));\n    \n    /**\n     * Constrói e configura o bioma das Estepes Cristalinas\n     * \n     * Este método define todas as propriedades do bioma, incluindo:\n     * - Efeitos climáticos e ambientais\n     * - Cores do céu, água e folhagem\n     * - Música e sons ambientais\n     * - Spawns de mobs (se houver)\n     * - Features de geração de mundo\n     * \n     * @param context Contexto de bootstrap para acessar registros\n     * @return Biome configurado das Estepes Cristalinas\n     */\n    public static Biome crystallineWastes(BootstrapContext<Biome> context) {\n        // Configuração dos efeitos especiais do bioma\n        BiomeSpecialEffects.Builder effectsBuilder = new BiomeSpecialEffects.Builder()\n            // Cor do céu - tom azulado cristalino\n            .skyColor(0x87CEEB) // SkyBlue\n            // Cor da névoa - tom roxo mágico\n            .fogColor(0x9370DB) // MediumPurple\n            // Cor da água - azul cristalino brilhante\n            .waterColor(0x00CED1) // DarkTurquoise\n            // Cor da névoa sobre a água\n            .waterFogColor(0x4682B4) // SteelBlue\n            // Cor da grama - tons cristalizados\n            .grassColorOverride(0xB0E0E6) // PowderBlue\n            // Cor das folhas - similar à grama\n            .foliageColorOverride(0xAFEEEE) // PaleTurquoise\n            // Música ambiente específica do bioma\n            .backgroundMusic(Musics.createGameMusic(SoundEvents.MUSIC_DISC_CHIRP))\n            // Som ambiente - vento suave\n            .ambientLoopSound(SoundEvents.AMBIENT_CAVE)\n            // Partículas ambientais serão adicionadas futuramente\n            // .ambientParticle(new AmbientParticleSettings(...))\n            ;\n        \n        // Configuração das propriedades climáticas\n        Biome.ClimateSettings climate = new Biome.ClimateSettings.Builder()\n            .precipitation(Biome.Precipitation.NONE) // Sem chuva\n            .temperature(0.1F) // Frio\n            .temperatureModifier(Biome.TemperatureModifier.NONE)\n            .downfall(0.0F) // Seco\n            .build();\n        \n        // Configuração dos spawns de mobs\n        MobSpawnSettings.Builder spawnBuilder = new MobSpawnSettings.Builder();\n        \n        // TODO: Adicionar spawns de mobs customizados quando implementados\n        // spawnBuilder.addSpawn(MobCategory.MONSTER, new MobSpawnSettings.SpawnerData(...));\n        \n        // Configuração das features de geração\n        BiomeGenerationSettings.Builder generationBuilder = new BiomeGenerationSettings.Builder(\n            context.lookup(Registries.PLACED_FEATURE), \n            context.lookup(Registries.CONFIGURED_CARVER)\n        );\n        \n        // Adiciona features básicas de cavernas e minérios\n        BiomeDefaultFeatures.addDefaultCarversAndLakes(generationBuilder);\n        BiomeDefaultFeatures.addDefaultCrystalFormations(generationBuilder);\n        BiomeDefaultFeatures.addDefaultMonsterRoom(generationBuilder);\n        BiomeDefaultFeatures.addDefaultUndergroundVariety(generationBuilder);\n        BiomeDefaultFeatures.addDefaultSprings(generationBuilder);\n        \n        // TODO: Adicionar features customizadas como:\n        // - Formações de cristais\n        // - Minérios de Aetherium dimensional\n        // - Estruturas antigas\n        \n        // Constrói e retorna o bioma final\n        return new Biome.BiomeBuilder()\n            .hasPrecipitation(false)\n            .temperature(0.1F)\n            .downfall(0.0F)\n            .specialEffects(effectsBuilder.build())\n            .mobSpawnSettings(spawnBuilder.build())\n            .generationSettings(generationBuilder.build())\n            .build();\n    }\n    \n    /**\n     * Método de bootstrap para registrar todos os biomas do mod\n     * \n     * Este método é chamado durante a geração de dados para registrar\n     * todos os biomas customizados com suas configurações.\n     * \n     * @param context Contexto de bootstrap\n     */\n    public static void bootstrap(BootstrapContext<Biome> context) {\n        context.register(CRYSTALLINE_WASTES, crystallineWastes(context));\n        \n        CronicasAetherium.LOGGER.info(\"Biomas customizados registrados:\");\n        CronicasAetherium.LOGGER.info(\"- Estepes Cristalinas: {}\", CRYSTALLINE_WASTES.location());\n    }\n}","size_bytes":5698},"src/main/java/com/cronicasaetherium/mod/world/dimension/ModDimensions.java":{"content":"package com.cronicasaetherium.mod.world.dimension;\n\nimport com.cronicasaetherium.mod.CronicasAetherium;\nimport net.minecraft.core.registries.Registries;\nimport net.minecraft.resources.ResourceKey;\nimport net.minecraft.resources.ResourceLocation;\nimport net.minecraft.world.level.Level;\nimport net.minecraft.world.level.dimension.DimensionType;\n\n/**\n * Registro e gerenciamento das dimensões customizadas do mod\n * \n * Esta classe define as dimensões especiais do Crônicas de Aetherium,\n * incluindo suas propriedades, chaves de acesso e configurações especiais.\n * \n * Dimensões implementadas:\n * - Crisol Arcano: Dimensão mágica com cristais e energia arcana\n * \n * As dimensões são registradas através de arquivos de data generation\n * em resources/data/cronicasaetherium/dimension/\n */\npublic class ModDimensions {\n    \n    /**\n     * Crisol Arcano - Dimensão mágica principal do mod\n     * \n     * Uma dimensão instável cheia de energia arcana cristalizada.\n     * Características:\n     * - Ambiente cristalino com partículas mágicas\n     * - Minérios de Aetherium mais abundantes\n     * - Estruturas antigas de civilizações perdidas\n     * - Biomas únicos com propriedades mágicas especiais\n     * \n     * Acesso: Portal ativado com Coração Instável\n     */\n    public static final ResourceKey<Level> ARCANE_CRUCIBLE = ResourceKey.create(Registries.DIMENSION,\n        ResourceLocation.fromNamespaceAndPath(CronicasAetherium.MODID, \"arcane_crucible\"));\n    \n    /**\n     * Tipo de dimensão para o Crisol Arcano\n     * Define as propriedades físicas da dimensão como altura, efeitos ambientais, etc.\n     */\n    public static final ResourceKey<DimensionType> ARCANE_CRUCIBLE_TYPE = ResourceKey.create(Registries.DIMENSION_TYPE,\n        ResourceLocation.fromNamespaceAndPath(CronicasAetherium.MODID, \"arcane_crucible\"));\n    \n    /**\n     * Método de inicialização das dimensões\n     * \n     * Este método registra as configurações necessárias para as dimensões customizadas.\n     * É chamado durante a inicialização do mod para garantir que todas as dimensões\n     * estejam disponíveis quando o mundo for carregado.\n     * \n     * Nota: As dimensões em si são registradas através de arquivos JSON\n     * na pasta de data generation, este método apenas inicializa referências.\n     */\n    public static void initialize() {\n        CronicasAetherium.LOGGER.info(\"Inicializando dimensões customizadas:\");\n        CronicasAetherium.LOGGER.info(\"- Crisol Arcano: {}\", ARCANE_CRUCIBLE.location());\n        \n        // TODO: Adicionar validações de configuração se necessário\n        // TODO: Registrar event handlers para entrada/saída da dimensão\n    }\n    \n    /**\n     * Verifica se um nível corresponde a uma das dimensões do mod\n     * \n     * @param level Nível a verificar\n     * @return true se for uma dimensão do mod, false caso contrário\n     */\n    public static boolean isModDimension(Level level) {\n        ResourceKey<Level> dimensionKey = level.dimension();\n        return ARCANE_CRUCIBLE.equals(dimensionKey);\n    }\n    \n    /**\n     * Verifica se um nível é especificamente o Crisol Arcano\n     * \n     * @param level Nível a verificar\n     * @return true se for o Crisol Arcano, false caso contrário\n     */\n    public static boolean isArcaneCrucible(Level level) {\n        return ARCANE_CRUCIBLE.equals(level.dimension());\n    }\n}","size_bytes":3413}},"version":1}